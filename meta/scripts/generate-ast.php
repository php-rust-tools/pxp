<?php

use Symfony\Component\Yaml\Yaml;

require_once __DIR__ . '/../vendor/autoload.php';

class AstGenerator
{
    /** @var array<string, array | string> */
    private array $ast;

    const RESERVED = ['as', 'derive'];

    const TEMPLATE = <<<'RUST'
    // This file is generated by meta/scripts/generate-ast.php.
    // Do not make modifications to this file directly.

    use crate::utils::CommaSeparated;
    use crate::Node;
    use pxp_syntax::comments::{CommentGroup, Comment};
    use pxp_type::Type;
    use pxp_token::Token;
    use pxp_span::Span;
    use pxp_symbol::Symbol;
    use pxp_syntax::backed_enum_type::BackedEnumType;
    use pxp_syntax::name::NameQualification;


    RUST;

    public function __construct()
    {
        $this->ast = Yaml::parseFile(__DIR__ . '/../../crates/pxp-ast/meta/ast.yaml');
    }

    public function generate(): string
    {
        $output = self::TEMPLATE;

        foreach ($this->ast as $node => $structure) {
            if ($this->isTypeAlias($structure)) {
                $output .= "pub type {$node} = {$structure};\n\n";
                continue;
            }

            $derives = ['Debug', 'PartialEq', 'Eq', 'Clone'];

            if (is_array($structure) && isset($structure['derive'])) {
                $derives = array_merge($derives, explode(', ', $structure['derive']));
            }

            $derives = array_unique($derives);
            $output .= "#[derive(" . implode(', ', $derives) . ")]\n";

            if ($this->isEnum($structure)) {
                $output .= "pub enum {$node} {\n";
            } else {
                $output .= "pub struct {$node} {\n";
            }

            if ($this->isEnum($structure)) {
                foreach ($structure as $field => $value) {
                    if (in_array($field, self::RESERVED, true)) {
                        continue;
                    }

                    $output .= "    {$field}";

                    if ($value === '') {
                        $output .= ",\n";
                    } elseif (is_string($value)) {
                        $output .= "({$value}),\n";
                    } elseif (is_array($value)) {
                        $output .= " {\n";

                        foreach ($value as $subfield => $subtype) {
                            $output .= "        {$subfield}: {$subtype},\n";
                        }

                        $output .= "    },\n";
                    }
                }
            } else {
                foreach ($structure as $field => $type) {
                    if (in_array($field, self::RESERVED, true)) {
                        continue;
                    }

                    $output .= "    pub {$field}: {$type},\n";
                }
            }

            $output .= "}\n\n";

            // Node trait implementation.
            $output .= "impl Node for {$node} {\n";

            // Node::name()
            $output .= "    fn name(&self) -> &'static str {\n";
            $output .= "        \"{$node}\"\n";
            $output .= "    }\n\n";

            // Node::children()
            $output .= "    fn children(&self) -> Vec<&dyn Node> {\n";

            if ($this->isEnum($structure)) {
                $output .= "        match self {\n";

                foreach ($structure as $field => $value) {
                    if (in_array($field, self::RESERVED, true)) {
                        continue;
                    }

                    if ($value === '') {
                        continue;
                    }

                    if (is_string($value) && $this->isNodeType($value)) {
                        $output .= "            Self::{$field}(node) => vec![node],\n";
                    }

                    if (is_array($value)) {
                        $output .= "            Self::{$field} { ";

                        $fields = [];

                        foreach ($value as $subfield => $subtype) {
                            $fields[] = $subfield;
                        }

                        $output .= implode(', ', $fields) . " } => {\n";
                        $output .= "                vec![\n";
                        foreach ($value as $subfield => $subtype) {
                            if (!$this->isNodeType($subtype)) {
                                continue;
                            }

                            $output .= "                {$subfield},\n";
                        }
                        $output .= "                ]\n";

                        $output .= "            }\n";
                    }
                }

                $output .= "            _ => vec![],\n";
                $output .= "        }\n";
            } else {
                $output .= "        vec![\n";

                foreach ($structure as $field => $type) {
                    if (in_array($field, self::RESERVED, true)) {
                        continue;
                    }

                    if ($this->isNodeType($type)) {
                        $output .= "            &self.{$field},\n";
                    }
                }

                $output .= "        ]";
            }

            $output .= "    }\n";
            $output .= "}\n\n";
        }

        return $output;
    }

    private function isNodeType(string $type): bool
    {
        return !in_array($type, ['Span', '(Span, Span)', 'Option<Span>', 'Token', 'Option<Token>', 'Symbol', 'Type', 'Type<Name>', 'Comment', 'CommentGroup', 'BackedEnumType', 'NameQualification', 'bool'], true);
    }

    private function isEnum(array | string $structure): bool
    {
        return is_array($structure) && isset($structure['as']) && $structure['as'] === 'Enum';
    }

    private function isTypeAlias(array | string $structure): bool
    {
        return is_string($structure);
    }
}

$generator = new AstGenerator();

file_put_contents(__DIR__ . '/../../crates/pxp-ast/src/generated.rs', $generator->generate());

echo "AST generated.\n";