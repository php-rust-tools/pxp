<?php

use Symfony\Component\Yaml\Yaml;

require_once __DIR__ . '/../vendor/autoload.php';

class VisitorMut
{
    const WALK_SUFFIX = '_mut';
    const VISITOR_TEMPLATE = <<<'EOF'
    // This file is automatically generated by the generate-visitor.php script.
    // Do not modify this file directly.
    #![allow(unused)]

    use pxp_ast::*;
    use crate::walk_mut::*;
    use pxp_span::Span;
    use pxp_syntax::comments::Comment;
    use pxp_type::Type;

    pub trait VisitorMut {
        fn visit(&mut self, node: &mut [Statement]) {
            walk_mut(self, node);
        }

        %s
    }
    EOF;

    const WALK_TEMPLATE = <<<'EOF'
    // This file is automatically generated by the generate-visitor.php script.
    // Do not modify this file directly.
    #![allow(unused)]

    use crate::visitor_mut::VisitorMut;
    use pxp_ast::*;

    pub fn walk_mut<V: VisitorMut + ?Sized>(visitor: &mut V, node: &mut [Statement]) {
        for statement in node {
            visitor.visit_statement(statement);
        }
    }

    %s
    EOF;

    const FILENAME = "visitor_mut.rs";
    const WALKERS = "walk_mut.rs";
    const NODE = "&mut ";
}

class Visitor
{
    const WALK_SUFFIX = '';
    const VISITOR_TEMPLATE = <<<'EOF'
    // This file is automatically generated by the generate-visitor.php script.
    // Do not modify this file directly.
    #![allow(unused)]

    use pxp_ast::*;
    use crate::walk::*;
    use pxp_span::Span;
    use pxp_syntax::comments::Comment;
    use pxp_type::Type;

    pub trait Visitor {
        fn visit(&mut self, node: &[Statement]) {
            walk(self, node);
        }

        %s
    }
    EOF;

    const WALK_TEMPLATE = <<<'EOF'
    // This file is automatically generated by the generate-visitor.php script.
    // Do not modify this file directly.
    #![allow(unused)]
    
    use crate::visitor::Visitor;
    use pxp_ast::*;

    pub fn walk<V: Visitor + ?Sized>(visitor: &mut V, node: &[Statement]) {
        for statement in node {
            visitor.visit_statement(statement);
        }
    }

    %s
    EOF;

    const FILENAME = "visitor.rs";
    const WALKERS = "walk.rs";
    const NODE = "&";
}

function main() {
    $yaml = Yaml::parseFile(__DIR__ . '/../../crates/pxp-ast/meta/ast.yaml');

    foreach ([VisitorMut::class, Visitor::class] as $trait) {
        $methods = generate_methods($yaml, $trait);
        $generated = sprintf($trait::VISITOR_TEMPLATE, implode("\n\n", $methods));    

        file_put_contents(__DIR__ . '/../../crates/pxp-visitor/src/' . $trait::FILENAME, $generated);

        echo "Generated " . class_basename($trait) . ".\n";

        $walkers = generate_walkers($yaml, $trait);
        $generated = sprintf($trait::WALK_TEMPLATE, implode("\n\n", $walkers));

        file_put_contents(__DIR__ . '/../../crates/pxp-visitor/src/' . $trait::WALKERS, $generated);

        echo "Generated walkers for " . class_basename($trait) . ".\n";
    }
}

function generate_walkers(array $yaml, string $trait): array
{
    $walkers = [];
    $trait = class_basename($trait);

    foreach ($yaml as $type => $fields) {
        if (is_string($fields)) {
            continue;
        }

        $enum = isset($fields['as']) && $fields['as'] === 'Enum';
        $fields = get_visitable_fields($fields);

        if (count($fields) === 0) {
            continue;
        }

        $function = sprintf("pub fn %s<V: %s + ?Sized>(visitor: &mut V, node: %s%s) {\n", type_name_to_walk_method($type, $trait), class_basename($trait), $trait::NODE, strip_type_to_root($type));

        if ($enum) {
            $function .= "    match node {\n";
            
            foreach ($fields as $variant => $field) {
                if ($type === 'StatementKind' && $variant === 'Comment') {
                    continue;
                }

                $function .= sprintf("        %s::%s", $type, $variant);

                if ($field === '') {
                    $function .= " => {},\n";
                } elseif (is_string($field)) {
                    $function .= sprintf("(inner) => visitor.%s(inner),\n", type_name_to_method($field));
                } elseif (is_array($field)) {
                    $function .= " { ";
                    foreach ($field as $subfield => $subtype) {
                        $function .= sprintf("%s, ", $subfield);
                    }
                    $function .= " } => {\n";
                    foreach ($field as $subfield => $subtype) {
                        if (in_array($subtype, ['CommentGroup', 'BackedEnumType', 'Type', 'Span', 'Option<Span>', 'Symbol', 'Token', 'bool', 'NameQualification', '(Span, Span)', 'Level', 'Box<Level>'])) {
                            continue;
                        }

                        if (is_string($subtype) && is_simple($subtype)) {
                            $function .= sprintf("    visitor.%s(%s);\n", type_name_to_method($subtype), $subfield);
                        }

                        if (is_string($subtype) && is_vec($subtype)) {
                            $function .= sprintf("    for item in %s {\n", $subfield);
                            $function .= sprintf("        visitor.%s(item);\n", type_name_to_method($subtype));
                            $function .= '}';
                        }

                        if (is_string($subtype) && is_option($subtype)) {
                            $function .= sprintf("    if let Some(item) = %s {\n", $subfield);
                            $function .= sprintf("        visitor.%s(item);\n", type_name_to_method($subtype));
                            $function .= '}';
                        }

                        if (is_string($subtype) && is_comma_separated($subtype)) {
                            $function .= sprintf("    for item in %s.inner {\n", $subfield);
                            $function .= sprintf("        visitor.%s(item);\n", type_name_to_method(strip_option($subtype)));
                            $function .= '}';
                        }
                    }
                    $function .= "},\n";
                }
            }

            if ($type === 'StatementKind' || $type === 'ExpressionKind') {
                $function .= "        _ => {},\n";
            }
            
            $function .= "    }\n";
        } else {
            foreach ($fields as $field => $type) {
                if (in_array($type, ['CommentGroup', 'BackedEnumType', 'Type', 'Span', 'Option<Span>', 'Symbol', 'Token', 'bool', 'NameQualification', '(Span, Span)', 'Level', 'Box<Level>'])) {
                    continue;
                }

                if (is_string($type) && is_simple($type)) {
                    $function .= sprintf("    visitor.%s(%snode.%s);\n", type_name_to_method($type), $trait::NODE, $field);
                }

                if (is_string($type) && is_vec($type)) {
                    $function .= sprintf("    for item in %snode.%s {\n", $trait::NODE, $field);
                    $function .= sprintf("        visitor.%s(item);\n", type_name_to_method($type));
                    $function .= '}';
                }

                if (is_string($type) && is_option($type)) {
                    $function .= sprintf("    if let Some(item) = %snode.%s {\n", $trait::NODE, $field);
                    $function .= sprintf("        visitor.%s(item);\n", type_name_to_method($type));
                    $function .= '}';
                }

                if (is_string($type) && is_comma_separated($type)) {
                    $function .= sprintf("    for item in %snode.%s.inner {\n", $trait::NODE, $field);
                    $function .= sprintf("        visitor.%s(item);\n", type_name_to_method(strip_option($type)));
                    $function .= '}';
                }
            }
        }

        $function .= "}";

        $walkers[] = $function;
    }

    return $walkers;
}

function generate_methods(array $yaml, string $trait): array
{
    $methods = [];

    foreach ($yaml as $type => $fields) {
        // Type alias.
        if (is_string($fields)) {
            continue;
        }

        $method = sprintf("fn %s(&mut self, node: %s%s) {\n", type_name_to_method($type), $trait::NODE, strip_type_to_root($type));
        $fields = get_visitable_fields($fields);

        if (count($fields) === 0) {
            goto end_method;
        }

        $method .= sprintf("   %s(self, node);\n", type_name_to_walk_method($type, $trait));

        end_method:
        $method .= "}\n";
        $methods[] = $method;
    }

    return $methods;
}

function strip_type_to_root(string $type): string
{
    return str($type)->afterLast('<')->before('>');
}

function get_visitable_fields(array $fields): array
{
    $reserved = ['as', 'derive'];

    return collect($fields)
        ->filter(function ($field, string $key) use ($reserved) {
            if (in_array($key, $reserved, true)) {
                return false;
            }

            if (is_string($field) && ($field === 'Span' || strip_type_to_root($field) === 'Span')) {
                return false;
            }

            if (is_string($field) && ($field === 'Token' || strip_type_to_root($field) === 'Token')) {
                return false;
            }

            if (is_string($field) && $field === 'bool') {
                return false;
            }

            return true;
        })
        ->all();
}

function type_name_to_method(string $type): string {
    if ($type === 'Block') {
        return 'visit';
    }

    return str(strip_type_to_root($type))->snake()->prepend('visit_');
}

function type_name_to_walk_method(string $type, string $trait): string {
    return str(strip_type_to_root($type))->snake()->prepend('walk_')->append($trait::WALK_SUFFIX);
}

function is_simple(string $type): bool {
    return !is_vec($type) && !is_option($type) && !is_comma_separated($type);
}

function is_comma_separated(string $type): bool {
    return str($type)->contains('CommaSeparated<');
}

function is_vec(string $type): bool {
    return str($type)->startsWith('Vec<');
}

function is_option(string $type): bool {
    return str($type)->startsWith('Option<');
}

function strip_option(string $type): string {
    return str($type)->after('Option<')->beforeLast('>');
}

main();