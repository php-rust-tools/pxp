// This file is automatically generated by the generate-visitor.php script.
// Do not modify this file directly.
#![allow(unused)]

use crate::visitor_mut::VisitorMut;
use pxp_ast::*;

pub fn walk_mut<V: VisitorMut + ?Sized>(visitor: &mut V, node: &mut [Statement]) {
    for statement in node {
        visitor.visit_statement(statement);
    }
}

pub fn walk_statement_mut<V: VisitorMut + ?Sized>(visitor: &mut V, node: &mut Statement) {
    visitor.visit_statement_kind(&mut node.kind);
}

pub fn walk_statement_kind_mut<V: VisitorMut + ?Sized>(visitor: &mut V, node: &mut StatementKind) {
    match node {
        StatementKind::FullOpeningTag(inner) => visitor.visit_full_opening_tag_statement(inner),
        StatementKind::ShortOpeningTag(inner) => visitor.visit_short_opening_tag_statement(inner),
        StatementKind::EchoOpeningTag(inner) => visitor.visit_echo_opening_tag_statement(inner),
        StatementKind::ClosingTag(inner) => visitor.visit_closing_tag_statement(inner),
        StatementKind::InlineHtml(inner) => visitor.visit_inline_html_statement(inner),
        StatementKind::Label(inner) => visitor.visit_label_statement(inner),
        StatementKind::Goto(inner) => visitor.visit_goto_statement(inner),
        StatementKind::HaltCompiler(inner) => visitor.visit_halt_compiler_statement(inner),
        StatementKind::Static(inner) => visitor.visit_static_statement(inner),
        StatementKind::DoWhile(inner) => visitor.visit_do_while_statement(inner),
        StatementKind::While(inner) => visitor.visit_while_statement(inner),
        StatementKind::For(inner) => visitor.visit_for_statement(inner),
        StatementKind::Foreach(inner) => visitor.visit_foreach_statement(inner),
        StatementKind::Break(inner) => visitor.visit_break_statement(inner),
        StatementKind::Continue(inner) => visitor.visit_continue_statement(inner),
        StatementKind::Constant(inner) => visitor.visit_constant_statement(inner),
        StatementKind::Function(inner) => visitor.visit_function_statement(inner),
        StatementKind::Class(inner) => visitor.visit_class_statement(inner),
        StatementKind::Trait(inner) => visitor.visit_trait_statement(inner),
        StatementKind::Interface(inner) => visitor.visit_interface_statement(inner),
        StatementKind::If(inner) => visitor.visit_if_statement(inner),
        StatementKind::Switch(inner) => visitor.visit_switch_statement(inner),
        StatementKind::Echo(inner) => visitor.visit_echo_statement(inner),
        StatementKind::Expression(inner) => visitor.visit_expression_statement(inner),
        StatementKind::Return(inner) => visitor.visit_return_statement(inner),
        StatementKind::Namespace(inner) => visitor.visit_namespace_statement(inner),
        StatementKind::Use(inner) => visitor.visit_use_statement(inner),
        StatementKind::GroupUse(inner) => visitor.visit_group_use_statement(inner),
        StatementKind::Try(inner) => visitor.visit_try_statement(inner),
        StatementKind::UnitEnum(inner) => visitor.visit_unit_enum_statement(inner),
        StatementKind::BackedEnum(inner) => visitor.visit_backed_enum_statement(inner),
        StatementKind::Block(inner) => visitor.visit_block_statement(inner),
        StatementKind::Global(inner) => visitor.visit_global_statement(inner),
        StatementKind::Declare(inner) => visitor.visit_declare_statement(inner),
        _ => {}
    }
}

pub fn walk_expression_mut<V: VisitorMut + ?Sized>(visitor: &mut V, node: &mut Expression) {
    visitor.visit_expression_kind(&mut node.kind);
}

pub fn walk_expression_kind_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut ExpressionKind,
) {
    match node {
        ExpressionKind::Eval(inner) => visitor.visit_eval_expression(inner),
        ExpressionKind::Empty(inner) => visitor.visit_empty_expression(inner),
        ExpressionKind::Die(inner) => visitor.visit_die_expression(inner),
        ExpressionKind::Exit(inner) => visitor.visit_exit_expression(inner),
        ExpressionKind::Isset(inner) => visitor.visit_isset_expression(inner),
        ExpressionKind::Unset(inner) => visitor.visit_unset_expression(inner),
        ExpressionKind::Print(inner) => visitor.visit_print_expression(inner),
        ExpressionKind::Literal(inner) => visitor.visit_literal(inner),
        ExpressionKind::ArithmeticOperation(inner) => {
            visitor.visit_arithmetic_operation_expression(inner)
        }
        ExpressionKind::AssignmentOperation(inner) => {
            visitor.visit_assignment_operation_expression(inner)
        }
        ExpressionKind::BitwiseOperation(inner) => {
            visitor.visit_bitwise_operation_expression(inner)
        }
        ExpressionKind::ComparisonOperation(inner) => {
            visitor.visit_comparison_operation_expression(inner)
        }
        ExpressionKind::LogicalOperation(inner) => {
            visitor.visit_logical_operation_expression(inner)
        }
        ExpressionKind::Concat(inner) => visitor.visit_concat_expression(inner),
        ExpressionKind::Instanceof(inner) => visitor.visit_instanceof_expression(inner),
        ExpressionKind::Reference(inner) => visitor.visit_reference_expression(inner),
        ExpressionKind::Parenthesized(inner) => visitor.visit_parenthesized_expression(inner),
        ExpressionKind::ErrorSuppress(inner) => visitor.visit_error_suppress_expression(inner),
        ExpressionKind::Identifier(inner) => visitor.visit_identifier(inner),
        ExpressionKind::Variable(inner) => visitor.visit_variable(inner),
        ExpressionKind::Include(inner) => visitor.visit_include_expression(inner),
        ExpressionKind::IncludeOnce(inner) => visitor.visit_include_once_expression(inner),
        ExpressionKind::Require(inner) => visitor.visit_require_expression(inner),
        ExpressionKind::RequireOnce(inner) => visitor.visit_require_once_expression(inner),
        ExpressionKind::FunctionCall(inner) => visitor.visit_function_call_expression(inner),
        ExpressionKind::FunctionClosureCreation(inner) => {
            visitor.visit_function_closure_creation_expression(inner)
        }
        ExpressionKind::MethodCall(inner) => visitor.visit_method_call_expression(inner),
        ExpressionKind::MethodClosureCreation(inner) => {
            visitor.visit_method_closure_creation_expression(inner)
        }
        ExpressionKind::NullsafeMethodCall(inner) => {
            visitor.visit_nullsafe_method_call_expression(inner)
        }
        ExpressionKind::StaticMethodCall(inner) => {
            visitor.visit_static_method_call_expression(inner)
        }
        ExpressionKind::StaticVariableMethodCall(inner) => {
            visitor.visit_static_variable_method_call_expression(inner)
        }
        ExpressionKind::StaticMethodClosureCreation(inner) => {
            visitor.visit_static_method_closure_creation_expression(inner)
        }
        ExpressionKind::StaticVariableMethodClosureCreation(inner) => {
            visitor.visit_static_variable_method_closure_creation_expression(inner)
        }
        ExpressionKind::PropertyFetch(inner) => visitor.visit_property_fetch_expression(inner),
        ExpressionKind::NullsafePropertyFetch(inner) => {
            visitor.visit_nullsafe_property_fetch_expression(inner)
        }
        ExpressionKind::StaticPropertyFetch(inner) => {
            visitor.visit_static_property_fetch_expression(inner)
        }
        ExpressionKind::ConstantFetch(inner) => visitor.visit_constant_fetch_expression(inner),
        ExpressionKind::ShortArray(inner) => visitor.visit_short_array_expression(inner),
        ExpressionKind::Array(inner) => visitor.visit_array_expression(inner),
        ExpressionKind::List(inner) => visitor.visit_list_expression(inner),
        ExpressionKind::Closure(inner) => visitor.visit_closure_expression(inner),
        ExpressionKind::ArrowFunction(inner) => visitor.visit_arrow_function_expression(inner),
        ExpressionKind::New(inner) => visitor.visit_new_expression(inner),
        ExpressionKind::InterpolatedString(inner) => {
            visitor.visit_interpolated_string_expression(inner)
        }
        ExpressionKind::Heredoc(inner) => visitor.visit_heredoc_expression(inner),
        ExpressionKind::Nowdoc(inner) => visitor.visit_nowdoc_expression(inner),
        ExpressionKind::ShellExec(inner) => visitor.visit_shell_exec_expression(inner),
        ExpressionKind::AnonymousClass(inner) => visitor.visit_anonymous_class_expression(inner),
        ExpressionKind::Bool(inner) => visitor.visit_bool_expression(inner),
        ExpressionKind::ArrayIndex(inner) => visitor.visit_array_index_expression(inner),
        ExpressionKind::MagicConstant(inner) => visitor.visit_magic_constant_expression(inner),
        ExpressionKind::ShortTernary(inner) => visitor.visit_short_ternary_expression(inner),
        ExpressionKind::Ternary(inner) => visitor.visit_ternary_expression(inner),
        ExpressionKind::Coalesce(inner) => visitor.visit_coalesce_expression(inner),
        ExpressionKind::Clone(inner) => visitor.visit_clone_expression(inner),
        ExpressionKind::Match(inner) => visitor.visit_match_expression(inner),
        ExpressionKind::Throw(inner) => visitor.visit_throw_expression(inner),
        ExpressionKind::Yield(inner) => visitor.visit_yield_expression(inner),
        ExpressionKind::YieldFrom(inner) => visitor.visit_yield_from_expression(inner),
        ExpressionKind::Cast(inner) => visitor.visit_cast_expression(inner),
        ExpressionKind::Name(inner) => visitor.visit_name(inner),
        _ => {}
    }
}

pub fn walk_expression_statement_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut ExpressionStatement,
) {
    visitor.visit_expression(&mut node.expression);
    visitor.visit_ending(&mut node.ending);
}

pub fn walk_global_statement_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut GlobalStatement,
) {
    for item in &mut node.variables {
        visitor.visit_variable(item);
    }
}

pub fn walk_block_statement_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut BlockStatement,
) {
    for item in &mut node.statements {
        visitor.visit_statement(item);
    }
}

pub fn walk_case_mut<V: VisitorMut + ?Sized>(visitor: &mut V, node: &mut Case) {
    if let Some(item) = &mut node.condition {
        visitor.visit_expression(item);
    }
    visitor.visit(&mut node.body);
}

pub fn walk_use_mut<V: VisitorMut + ?Sized>(visitor: &mut V, node: &mut Use) {
    visitor.visit_name(&mut node.name);
    if let Some(item) = &mut node.alias {
        visitor.visit_simple_identifier(item);
    }
    if let Some(item) = &mut node.kind {
        visitor.visit_use_kind(item);
    }
}

pub fn walk_use_kind_mut<V: VisitorMut + ?Sized>(visitor: &mut V, node: &mut UseKind) {
    match node {
        UseKind::Normal => {}
        UseKind::Function => {}
        UseKind::Const => {}
        _ => {}
    }
}

pub fn walk_eval_expression_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut EvalExpression,
) {
    visitor.visit_single_argument(&mut node.argument);
}

pub fn walk_empty_expression_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut EmptyExpression,
) {
    visitor.visit_single_argument(&mut node.argument);
}

pub fn walk_die_expression_mut<V: VisitorMut + ?Sized>(visitor: &mut V, node: &mut DieExpression) {
    if let Some(item) = &mut node.argument {
        visitor.visit_single_argument(item);
    }
}

pub fn walk_exit_expression_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut ExitExpression,
) {
    if let Some(item) = &mut node.argument {
        visitor.visit_single_argument(item);
    }
}

pub fn walk_isset_expression_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut IssetExpression,
) {
    visitor.visit_argument_list(&mut node.arguments);
}

pub fn walk_unset_expression_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut UnsetExpression,
) {
    visitor.visit_argument_list(&mut node.arguments);
}

pub fn walk_print_expression_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut PrintExpression,
) {
    if let Some(item) = &mut node.value {
        visitor.visit_expression(item);
    }
    if let Some(item) = &mut node.argument {
        visitor.visit_single_argument(item);
    }
}

pub fn walk_concat_expression_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut ConcatExpression,
) {
    visitor.visit_expression(&mut node.left);
    visitor.visit_expression(&mut node.right);
}

pub fn walk_instanceof_expression_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut InstanceofExpression,
) {
    visitor.visit_expression(&mut node.left);
    visitor.visit_expression(&mut node.right);
}

pub fn walk_reference_expression_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut ReferenceExpression,
) {
    visitor.visit_expression(&mut node.right);
}

pub fn walk_parenthesized_expression_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut ParenthesizedExpression,
) {
    visitor.visit_expression(&mut node.expr);
}

pub fn walk_error_suppress_expression_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut ErrorSuppressExpression,
) {
    visitor.visit_expression(&mut node.expr);
}

pub fn walk_include_expression_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut IncludeExpression,
) {
    visitor.visit_expression(&mut node.path);
}

pub fn walk_include_once_expression_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut IncludeOnceExpression,
) {
    visitor.visit_expression(&mut node.path);
}

pub fn walk_require_expression_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut RequireExpression,
) {
    visitor.visit_expression(&mut node.path);
}

pub fn walk_require_once_expression_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut RequireOnceExpression,
) {
    visitor.visit_expression(&mut node.path);
}

pub fn walk_function_call_expression_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut FunctionCallExpression,
) {
    visitor.visit_expression(&mut node.target);
    visitor.visit_argument_list(&mut node.arguments);
}

pub fn walk_function_closure_creation_expression_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut FunctionClosureCreationExpression,
) {
    visitor.visit_expression(&mut node.target);
    visitor.visit_argument_placeholder(&mut node.placeholder);
}

pub fn walk_method_call_expression_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut MethodCallExpression,
) {
    visitor.visit_expression(&mut node.target);
    visitor.visit_expression(&mut node.method);
    visitor.visit_argument_list(&mut node.arguments);
}

pub fn walk_method_closure_creation_expression_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut MethodClosureCreationExpression,
) {
    visitor.visit_expression(&mut node.target);
    visitor.visit_expression(&mut node.method);
    visitor.visit_argument_placeholder(&mut node.placeholder);
}

pub fn walk_nullsafe_method_call_expression_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut NullsafeMethodCallExpression,
) {
    visitor.visit_expression(&mut node.target);
    visitor.visit_expression(&mut node.method);
    visitor.visit_argument_list(&mut node.arguments);
}

pub fn walk_static_method_call_expression_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut StaticMethodCallExpression,
) {
    visitor.visit_expression(&mut node.target);
    visitor.visit_identifier(&mut node.method);
    visitor.visit_argument_list(&mut node.arguments);
}

pub fn walk_static_variable_method_call_expression_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut StaticVariableMethodCallExpression,
) {
    visitor.visit_expression(&mut node.target);
    visitor.visit_variable(&mut node.method);
    visitor.visit_argument_list(&mut node.arguments);
}

pub fn walk_static_method_closure_creation_expression_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut StaticMethodClosureCreationExpression,
) {
    visitor.visit_expression(&mut node.target);
    visitor.visit_identifier(&mut node.method);
    visitor.visit_argument_placeholder(&mut node.placeholder);
}

pub fn walk_static_variable_method_closure_creation_expression_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut StaticVariableMethodClosureCreationExpression,
) {
    visitor.visit_expression(&mut node.target);
    visitor.visit_variable(&mut node.method);
    visitor.visit_argument_placeholder(&mut node.placeholder);
}

pub fn walk_property_fetch_expression_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut PropertyFetchExpression,
) {
    visitor.visit_expression(&mut node.target);
    visitor.visit_expression(&mut node.property);
}

pub fn walk_nullsafe_property_fetch_expression_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut NullsafePropertyFetchExpression,
) {
    visitor.visit_expression(&mut node.target);
    visitor.visit_expression(&mut node.property);
}

pub fn walk_static_property_fetch_expression_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut StaticPropertyFetchExpression,
) {
    visitor.visit_expression(&mut node.target);
    visitor.visit_variable(&mut node.property);
}

pub fn walk_constant_fetch_expression_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut ConstantFetchExpression,
) {
    visitor.visit_expression(&mut node.target);
    visitor.visit_identifier(&mut node.constant);
}

pub fn walk_short_array_expression_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut ShortArrayExpression,
) {
    for item in &mut node.items.inner {
        visitor.visit_array_item(item);
    }
}

pub fn walk_array_expression_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut ArrayExpression,
) {
    for item in &mut node.items.inner {
        visitor.visit_array_item(item);
    }
}

pub fn walk_list_expression_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut ListExpression,
) {
    for item in &mut node.items {
        visitor.visit_list_entry(item);
    }
}

pub fn walk_new_expression_mut<V: VisitorMut + ?Sized>(visitor: &mut V, node: &mut NewExpression) {
    visitor.visit_expression(&mut node.target);
    if let Some(item) = &mut node.arguments {
        visitor.visit_argument_list(item);
    }
}

pub fn walk_interpolated_string_expression_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut InterpolatedStringExpression,
) {
    for item in &mut node.parts {
        visitor.visit_string_part(item);
    }
}

pub fn walk_heredoc_expression_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut HeredocExpression,
) {
    for item in &mut node.parts {
        visitor.visit_string_part(item);
    }
}

pub fn walk_shell_exec_expression_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut ShellExecExpression,
) {
    for item in &mut node.parts {
        visitor.visit_string_part(item);
    }
}

pub fn walk_array_index_expression_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut ArrayIndexExpression,
) {
    visitor.visit_expression(&mut node.array);
    if let Some(item) = &mut node.index {
        visitor.visit_expression(item);
    }
}

pub fn walk_short_ternary_expression_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut ShortTernaryExpression,
) {
    visitor.visit_expression(&mut node.condition);
    visitor.visit_expression(&mut node.r#else);
}

pub fn walk_ternary_expression_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut TernaryExpression,
) {
    visitor.visit_expression(&mut node.condition);
    visitor.visit_expression(&mut node.then);
    visitor.visit_expression(&mut node.r#else);
}

pub fn walk_coalesce_expression_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut CoalesceExpression,
) {
    visitor.visit_expression(&mut node.lhs);
    visitor.visit_expression(&mut node.rhs);
}

pub fn walk_clone_expression_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut CloneExpression,
) {
    visitor.visit_expression(&mut node.target);
}

pub fn walk_match_expression_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut MatchExpression,
) {
    visitor.visit_expression(&mut node.condition);
    if let Some(item) = &mut node.default {
        visitor.visit_default_match_arm(item);
    }
    for item in &mut node.arms {
        visitor.visit_match_arm(item);
    }
}

pub fn walk_throw_expression_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut ThrowExpression,
) {
    visitor.visit_expression(&mut node.value);
}

pub fn walk_yield_expression_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut YieldExpression,
) {
    if let Some(item) = &mut node.key {
        visitor.visit_expression(item);
    }
    if let Some(item) = &mut node.value {
        visitor.visit_expression(item);
    }
}

pub fn walk_yield_from_expression_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut YieldFromExpression,
) {
    visitor.visit_expression(&mut node.value);
}

pub fn walk_cast_expression_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut CastExpression,
) {
    visitor.visit_cast_kind(&mut node.kind);
    visitor.visit_expression(&mut node.value);
}

pub fn walk_default_match_arm_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut DefaultMatchArm,
) {
    visitor.visit_expression(&mut node.body);
}

pub fn walk_match_arm_mut<V: VisitorMut + ?Sized>(visitor: &mut V, node: &mut MatchArm) {
    for item in &mut node.conditions {
        visitor.visit_expression(item);
    }
    visitor.visit_expression(&mut node.body);
}

pub fn walk_string_part_mut<V: VisitorMut + ?Sized>(visitor: &mut V, node: &mut StringPart) {
    match node {
        StringPart::Literal(inner) => visitor.visit_literal_string_part(inner),
        StringPart::Expression(inner) => visitor.visit_expression_string_part(inner),
        _ => {}
    }
}

pub fn walk_expression_string_part_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut ExpressionStringPart,
) {
    visitor.visit_expression(&mut node.expression);
}

pub fn walk_array_item_mut<V: VisitorMut + ?Sized>(visitor: &mut V, node: &mut ArrayItem) {
    match node {
        ArrayItem::Value { span, value } => {
            visitor.visit_expression(value);
        }
        ArrayItem::ReferencedValue {
            span,
            ampersand,
            value,
        } => {
            visitor.visit_expression(value);
        }
        ArrayItem::SpreadValue {
            span,
            ellipsis,
            value,
        } => {
            visitor.visit_expression(value);
        }
        ArrayItem::KeyValue {
            span,
            key,
            double_arrow,
            value,
        } => {
            visitor.visit_expression(key);
            visitor.visit_expression(value);
        }
        ArrayItem::ReferencedKeyValue {
            span,
            key,
            double_arrow,
            ampersand,
            value,
        } => {
            visitor.visit_expression(key);
            visitor.visit_expression(value);
        }
        _ => {}
    }
}

pub fn walk_list_entry_mut<V: VisitorMut + ?Sized>(visitor: &mut V, node: &mut ListEntry) {
    match node {
        ListEntry::Value { span, value } => {
            visitor.visit_expression(value);
        }
        ListEntry::KeyValue {
            span,
            key,
            double_arrow,
            value,
        } => {
            visitor.visit_expression(key);
            visitor.visit_expression(value);
        }
        _ => {}
    }
}

pub fn walk_positional_argument_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut PositionalArgument,
) {
    visitor.visit_expression(&mut node.value);
}

pub fn walk_named_argument_mut<V: VisitorMut + ?Sized>(visitor: &mut V, node: &mut NamedArgument) {
    visitor.visit_simple_identifier(&mut node.name);
    visitor.visit_expression(&mut node.value);
}

pub fn walk_argument_mut<V: VisitorMut + ?Sized>(visitor: &mut V, node: &mut Argument) {
    match node {
        Argument::Positional(inner) => visitor.visit_positional_argument(inner),
        Argument::Named(inner) => visitor.visit_named_argument(inner),
        _ => {}
    }
}

pub fn walk_argument_list_mut<V: VisitorMut + ?Sized>(visitor: &mut V, node: &mut ArgumentList) {
    for item in &mut node.arguments {
        visitor.visit_argument(item);
    }
}

pub fn walk_single_argument_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut SingleArgument,
) {
    if let Some(item) = &mut node.argument {
        visitor.visit_argument(item);
    }
}

pub fn walk_attribute_mut<V: VisitorMut + ?Sized>(visitor: &mut V, node: &mut Attribute) {
    visitor.visit_name(&mut node.name);
    if let Some(item) = &mut node.arguments {
        visitor.visit_argument_list(item);
    }
}

pub fn walk_attribute_group_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut AttributeGroup,
) {
    for item in &mut node.members {
        visitor.visit_attribute(item);
    }
}

pub fn walk_class_body_mut<V: VisitorMut + ?Sized>(visitor: &mut V, node: &mut ClassBody) {
    for item in &mut node.members {
        visitor.visit_classish_member(item);
    }
}

pub fn walk_class_statement_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut ClassStatement,
) {
    for item in &mut node.attributes {
        visitor.visit_attribute_group(item);
    }
    visitor.visit_class_modifier_group(&mut node.modifiers);
    visitor.visit_name(&mut node.name);
    if let Some(item) = &mut node.extends {
        visitor.visit_class_extends(item);
    }
    if let Some(item) = &mut node.implements {
        visitor.visit_class_implements(item);
    }
    visitor.visit_class_body(&mut node.body);
}

pub fn walk_anonymous_class_body_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut AnonymousClassBody,
) {
    for item in &mut node.members {
        visitor.visit_classish_member(item);
    }
}

pub fn walk_anonymous_class_expression_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut AnonymousClassExpression,
) {
    for item in &mut node.attributes {
        visitor.visit_attribute_group(item);
    }
    if let Some(item) = &mut node.extends {
        visitor.visit_class_extends(item);
    }
    if let Some(item) = &mut node.implements {
        visitor.visit_class_implements(item);
    }
    visitor.visit_anonymous_class_body(&mut node.body);
}

pub fn walk_class_extends_mut<V: VisitorMut + ?Sized>(visitor: &mut V, node: &mut ClassExtends) {
    visitor.visit_name(&mut node.parent);
}

pub fn walk_class_implements_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut ClassImplements,
) {
    for item in &mut node.interfaces.inner {
        visitor.visit_name(item);
    }
}

pub fn walk_classish_member_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut ClassishMember,
) {
    match node {
        ClassishMember::Constant(inner) => visitor.visit_classish_constant(inner),
        ClassishMember::TraitUsage(inner) => visitor.visit_trait_usage(inner),
        ClassishMember::Property(inner) => visitor.visit_property(inner),
        ClassishMember::VariableProperty(inner) => visitor.visit_variable_property(inner),
        ClassishMember::AbstractMethod(inner) => visitor.visit_abstract_method(inner),
        ClassishMember::AbstractConstructor(inner) => visitor.visit_abstract_constructor(inner),
        ClassishMember::ConcreteMethod(inner) => visitor.visit_concrete_method(inner),
        ClassishMember::ConcreteConstructor(inner) => visitor.visit_concrete_constructor(inner),
        _ => {}
    }
}

pub fn walk_constant_entry_mut<V: VisitorMut + ?Sized>(visitor: &mut V, node: &mut ConstantEntry) {
    visitor.visit_name(&mut node.name);
    visitor.visit_expression(&mut node.value);
}

pub fn walk_classish_constant_entry_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut ClassishConstantEntry,
) {
    visitor.visit_simple_identifier(&mut node.name);
    visitor.visit_expression(&mut node.value);
}

pub fn walk_constant_statement_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut ConstantStatement,
) {
    for item in &mut node.entries {
        visitor.visit_constant_entry(item);
    }
}

pub fn walk_classish_constant_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut ClassishConstant,
) {
    for item in &mut node.attributes {
        visitor.visit_attribute_group(item);
    }
    visitor.visit_constant_modifier_group(&mut node.modifiers);
    if let Some(item) = &mut node.data_type {
        visitor.visit_data_type(item);
    }
    for item in &mut node.entries {
        visitor.visit_classish_constant_entry(item);
    }
}

pub fn walk_if_statement_mut<V: VisitorMut + ?Sized>(visitor: &mut V, node: &mut IfStatement) {
    visitor.visit_expression(&mut node.condition);
    visitor.visit_if_statement_body(&mut node.body);
}

pub fn walk_if_statement_body_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut IfStatementBody,
) {
    match node {
        IfStatementBody::Statement {
            span,
            statement,
            elseifs,
            r#else,
        } => {
            visitor.visit_statement(statement);
            for item in elseifs {
                visitor.visit_if_statement_else_if(item);
            }
            if let Some(item) = r#else {
                visitor.visit_if_statement_else(item);
            }
        }
        IfStatementBody::Block {
            span,
            colon,
            statements,
            elseifs,
            r#else,
            endif,
            ending,
        } => {
            for item in statements {
                visitor.visit_statement(item);
            }
            for item in elseifs {
                visitor.visit_if_statement_else_if_block(item);
            }
            if let Some(item) = r#else {
                visitor.visit_if_statement_else_block(item);
            }
            visitor.visit_ending(ending);
        }
        _ => {}
    }
}

pub fn walk_if_statement_else_if_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut IfStatementElseIf,
) {
    visitor.visit_expression(&mut node.condition);
    visitor.visit_statement(&mut node.statement);
}

pub fn walk_if_statement_else_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut IfStatementElse,
) {
    visitor.visit_statement(&mut node.statement);
}

pub fn walk_if_statement_else_if_block_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut IfStatementElseIfBlock,
) {
    visitor.visit_expression(&mut node.condition);
    for item in &mut node.statements {
        visitor.visit_statement(item);
    }
}

pub fn walk_if_statement_else_block_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut IfStatementElseBlock,
) {
    for item in &mut node.statements {
        visitor.visit_statement(item);
    }
}

pub fn walk_data_type_mut<V: VisitorMut + ?Sized>(visitor: &mut V, node: &mut DataType) {}

pub fn walk_declare_entry_mut<V: VisitorMut + ?Sized>(visitor: &mut V, node: &mut DeclareEntry) {
    visitor.visit_simple_identifier(&mut node.key);
    visitor.visit_literal(&mut node.value);
}

pub fn walk_declare_entry_group_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut DeclareEntryGroup,
) {
    for item in &mut node.entries {
        visitor.visit_declare_entry(item);
    }
}

pub fn walk_declare_body_mut<V: VisitorMut + ?Sized>(visitor: &mut V, node: &mut DeclareBody) {
    match node {
        DeclareBody::Noop { span, semicolon } => {}
        DeclareBody::Braced {
            span,
            left_brace,
            statements,
            right_brace,
        } => {
            for item in statements {
                visitor.visit_statement(item);
            }
        }
        DeclareBody::Expression {
            span,
            expression,
            semicolon,
        } => {
            visitor.visit_expression(expression);
        }
        DeclareBody::Block {
            span,
            colon,
            statements,
            enddeclare,
            semicolon,
        } => {
            for item in statements {
                visitor.visit_statement(item);
            }
        }
        _ => {}
    }
}

pub fn walk_declare_statement_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut DeclareStatement,
) {
    visitor.visit_declare_entry_group(&mut node.entries);
    visitor.visit_declare_body(&mut node.body);
}

pub fn walk_unit_enum_case_mut<V: VisitorMut + ?Sized>(visitor: &mut V, node: &mut UnitEnumCase) {
    for item in &mut node.attributes {
        visitor.visit_attribute_group(item);
    }
    visitor.visit_simple_identifier(&mut node.name);
}

pub fn walk_unit_enum_member_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut UnitEnumMember,
) {
    match node {
        UnitEnumMember::Case(inner) => visitor.visit_unit_enum_case(inner),
        UnitEnumMember::Classish(inner) => visitor.visit_classish_member(inner),
        _ => {}
    }
}

pub fn walk_unit_enum_body_mut<V: VisitorMut + ?Sized>(visitor: &mut V, node: &mut UnitEnumBody) {
    for item in &mut node.members {
        visitor.visit_unit_enum_member(item);
    }
}

pub fn walk_unit_enum_statement_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut UnitEnumStatement,
) {
    for item in &mut node.attributes {
        visitor.visit_attribute_group(item);
    }
    visitor.visit_name(&mut node.name);
    for item in &mut node.implements {
        visitor.visit_name(item);
    }
    visitor.visit_unit_enum_body(&mut node.body);
}

pub fn walk_backed_enum_case_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut BackedEnumCase,
) {
    for item in &mut node.attributes {
        visitor.visit_attribute_group(item);
    }
    visitor.visit_simple_identifier(&mut node.name);
    visitor.visit_expression(&mut node.value);
}

pub fn walk_backed_enum_member_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut BackedEnumMember,
) {
    match node {
        BackedEnumMember::Case(inner) => visitor.visit_backed_enum_case(inner),
        BackedEnumMember::Classish(inner) => visitor.visit_classish_member(inner),
        _ => {}
    }
}

pub fn walk_backed_enum_body_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut BackedEnumBody,
) {
    for item in &mut node.members {
        visitor.visit_backed_enum_member(item);
    }
}

pub fn walk_backed_enum_statement_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut BackedEnumStatement,
) {
    for item in &mut node.attributes {
        visitor.visit_attribute_group(item);
    }
    visitor.visit_name(&mut node.name);
    for item in &mut node.implements {
        visitor.visit_name(item);
    }
    visitor.visit_backed_enum_body(&mut node.body);
}

pub fn walk_return_type_mut<V: VisitorMut + ?Sized>(visitor: &mut V, node: &mut ReturnType) {
    visitor.visit_data_type(&mut node.data_type);
}

pub fn walk_function_parameter_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut FunctionParameter,
) {
    visitor.visit_simple_variable(&mut node.name);
    for item in &mut node.attributes {
        visitor.visit_attribute_group(item);
    }
    if let Some(item) = &mut node.data_type {
        visitor.visit_data_type(item);
    }
    if let Some(item) = &mut node.default {
        visitor.visit_expression(item);
    }
}

pub fn walk_function_parameter_list_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut FunctionParameterList,
) {
    for item in &mut node.parameters.inner {
        visitor.visit_function_parameter(item);
    }
}

pub fn walk_function_body_mut<V: VisitorMut + ?Sized>(visitor: &mut V, node: &mut FunctionBody) {
    for item in &mut node.statements {
        visitor.visit_statement(item);
    }
}

pub fn walk_function_statement_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut FunctionStatement,
) {
    for item in &mut node.attributes {
        visitor.visit_attribute_group(item);
    }
    visitor.visit_name(&mut node.name);
    visitor.visit_function_parameter_list(&mut node.parameters);
    if let Some(item) = &mut node.return_type {
        visitor.visit_return_type(item);
    }
    visitor.visit_function_body(&mut node.body);
}

pub fn walk_closure_use_variable_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut ClosureUseVariable,
) {
    visitor.visit_simple_variable(&mut node.variable);
}

pub fn walk_closure_use_mut<V: VisitorMut + ?Sized>(visitor: &mut V, node: &mut ClosureUse) {
    for item in &mut node.variables.inner {
        visitor.visit_closure_use_variable(item);
    }
}

pub fn walk_closure_expression_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut ClosureExpression,
) {
    for item in &mut node.attributes {
        visitor.visit_attribute_group(item);
    }
    visitor.visit_function_parameter_list(&mut node.parameters);
    if let Some(item) = &mut node.uses {
        visitor.visit_closure_use(item);
    }
    if let Some(item) = &mut node.return_type {
        visitor.visit_return_type(item);
    }
    visitor.visit_function_body(&mut node.body);
}

pub fn walk_arrow_function_expression_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut ArrowFunctionExpression,
) {
    for item in &mut node.attributes {
        visitor.visit_attribute_group(item);
    }
    visitor.visit_function_parameter_list(&mut node.parameters);
    if let Some(item) = &mut node.return_type {
        visitor.visit_return_type(item);
    }
    visitor.visit_expression(&mut node.body);
}

pub fn walk_constructor_parameter_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut ConstructorParameter,
) {
    for item in &mut node.attributes {
        visitor.visit_attribute_group(item);
    }
    visitor.visit_simple_variable(&mut node.name);
    if let Some(item) = &mut node.data_type {
        visitor.visit_data_type(item);
    }
    if let Some(item) = &mut node.default {
        visitor.visit_expression(item);
    }
    visitor.visit_promoted_property_modifier_group(&mut node.modifiers);
}

pub fn walk_constructor_parameter_list_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut ConstructorParameterList,
) {
    for item in &mut node.parameters.inner {
        visitor.visit_constructor_parameter(item);
    }
}

pub fn walk_abstract_constructor_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut AbstractConstructor,
) {
    for item in &mut node.attributes {
        visitor.visit_attribute_group(item);
    }
    visitor.visit_method_modifier_group(&mut node.modifiers);
    visitor.visit_simple_identifier(&mut node.name);
    visitor.visit_constructor_parameter_list(&mut node.parameters);
}

pub fn walk_concrete_constructor_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut ConcreteConstructor,
) {
    for item in &mut node.attributes {
        visitor.visit_attribute_group(item);
    }
    visitor.visit_method_modifier_group(&mut node.modifiers);
    visitor.visit_simple_identifier(&mut node.name);
    visitor.visit_constructor_parameter_list(&mut node.parameters);
    visitor.visit_method_body(&mut node.body);
}

pub fn walk_abstract_method_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut AbstractMethod,
) {
    for item in &mut node.attributes {
        visitor.visit_attribute_group(item);
    }
    visitor.visit_method_modifier_group(&mut node.modifiers);
    visitor.visit_simple_identifier(&mut node.name);
    visitor.visit_function_parameter_list(&mut node.parameters);
    if let Some(item) = &mut node.return_type {
        visitor.visit_return_type(item);
    }
}

pub fn walk_concrete_method_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut ConcreteMethod,
) {
    for item in &mut node.attributes {
        visitor.visit_attribute_group(item);
    }
    visitor.visit_method_modifier_group(&mut node.modifiers);
    visitor.visit_simple_identifier(&mut node.name);
    visitor.visit_function_parameter_list(&mut node.parameters);
    if let Some(item) = &mut node.return_type {
        visitor.visit_return_type(item);
    }
    visitor.visit_method_body(&mut node.body);
}

pub fn walk_method_body_mut<V: VisitorMut + ?Sized>(visitor: &mut V, node: &mut MethodBody) {
    for item in &mut node.statements {
        visitor.visit_statement(item);
    }
}

pub fn walk_label_statement_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut LabelStatement,
) {
    visitor.visit_simple_identifier(&mut node.label);
}

pub fn walk_goto_statement_mut<V: VisitorMut + ?Sized>(visitor: &mut V, node: &mut GotoStatement) {
    visitor.visit_simple_identifier(&mut node.label);
}

pub fn walk_identifier_mut<V: VisitorMut + ?Sized>(visitor: &mut V, node: &mut Identifier) {
    match node {
        Identifier::SimpleIdentifier(inner) => visitor.visit_simple_identifier(inner),
        Identifier::DynamicIdentifier(inner) => visitor.visit_dynamic_identifier(inner),
        _ => {}
    }
}

pub fn walk_dynamic_identifier_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut DynamicIdentifier,
) {
    visitor.visit_expression(&mut node.expr);
}

pub fn walk_interface_extends_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut InterfaceExtends,
) {
    for item in &mut node.parents.inner {
        visitor.visit_name(item);
    }
}

pub fn walk_interface_body_mut<V: VisitorMut + ?Sized>(visitor: &mut V, node: &mut InterfaceBody) {
    for item in &mut node.members {
        visitor.visit_classish_member(item);
    }
}

pub fn walk_interface_statement_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut InterfaceStatement,
) {
    for item in &mut node.attributes {
        visitor.visit_attribute_group(item);
    }
    visitor.visit_name(&mut node.name);
    if let Some(item) = &mut node.extends {
        visitor.visit_interface_extends(item);
    }
    visitor.visit_interface_body(&mut node.body);
}

pub fn walk_literal_mut<V: VisitorMut + ?Sized>(visitor: &mut V, node: &mut Literal) {
    visitor.visit_literal_kind(&mut node.kind);
}

pub fn walk_literal_kind_mut<V: VisitorMut + ?Sized>(visitor: &mut V, node: &mut LiteralKind) {
    match node {
        LiteralKind::Integer => {}
        LiteralKind::Float => {}
        LiteralKind::String => {}
        LiteralKind::Missing => {}
        _ => {}
    }
}

pub fn walk_foreach_statement_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut ForeachStatement,
) {
    visitor.visit_foreach_statement_iterator(&mut node.iterator);
    visitor.visit_foreach_statement_body(&mut node.body);
}

pub fn walk_foreach_statement_iterator_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut ForeachStatementIterator,
) {
    match node {
        ForeachStatementIterator::Value {
            span,
            expression,
            r#as,
            ampersand,
            value,
        } => {
            visitor.visit_expression(expression);
            visitor.visit_expression(value);
        }
        ForeachStatementIterator::KeyAndValue {
            span,
            expression,
            r#as,
            ampersand,
            key,
            double_arrow,
            value,
        } => {
            visitor.visit_expression(expression);
            visitor.visit_expression(key);
            visitor.visit_expression(value);
        }
        _ => {}
    }
}

pub fn walk_foreach_statement_body_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut ForeachStatementBody,
) {
    match node {
        ForeachStatementBody::Statement { span, statement } => {
            visitor.visit_statement(statement);
        }
        ForeachStatementBody::Block {
            span,
            colon,
            statements,
            endforeach,
            ending,
        } => {
            for item in statements {
                visitor.visit_statement(item);
            }
            visitor.visit_ending(ending);
        }
        _ => {}
    }
}

pub fn walk_for_statement_mut<V: VisitorMut + ?Sized>(visitor: &mut V, node: &mut ForStatement) {
    visitor.visit_for_statement_iterator(&mut node.iterator);
    visitor.visit_for_statement_body(&mut node.body);
}

pub fn walk_for_statement_iterator_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut ForStatementIterator,
) {
    for item in &mut node.initializations.inner {
        visitor.visit_expression(item);
    }
    for item in &mut node.conditions.inner {
        visitor.visit_expression(item);
    }
    for item in &mut node.r#loop.inner {
        visitor.visit_expression(item);
    }
}

pub fn walk_for_statement_body_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut ForStatementBody,
) {
    match node {
        ForStatementBody::Statement { span, statement } => {
            visitor.visit_statement(statement);
        }
        ForStatementBody::Block {
            span,
            colon,
            statements,
            endfor,
            ending,
        } => {
            for item in statements {
                visitor.visit_statement(item);
            }
            visitor.visit_ending(ending);
        }
        _ => {}
    }
}

pub fn walk_do_while_statement_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut DoWhileStatement,
) {
    visitor.visit_statement(&mut node.body);
    visitor.visit_expression(&mut node.condition);
}

pub fn walk_while_statement_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut WhileStatement,
) {
    visitor.visit_expression(&mut node.condition);
    visitor.visit_while_statement_body(&mut node.body);
}

pub fn walk_while_statement_body_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut WhileStatementBody,
) {
    match node {
        WhileStatementBody::Statement { span, statement } => {
            visitor.visit_statement(statement);
        }
        WhileStatementBody::Block {
            span,
            colon,
            statements,
            endwhile,
            ending,
        } => {
            for item in statements {
                visitor.visit_statement(item);
            }
            visitor.visit_ending(ending);
        }
        _ => {}
    }
}

pub fn walk_level_mut<V: VisitorMut + ?Sized>(visitor: &mut V, node: &mut Level) {
    match node {
        Level::Literal(inner) => visitor.visit_literal(inner),
        Level::Parenthesized {
            span,
            left_parenthesis,
            level,
            right_parenthesis,
        } => {}
        _ => {}
    }
}

pub fn walk_break_statement_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut BreakStatement,
) {
    visitor.visit_ending(&mut node.ending);
}

pub fn walk_continue_statement_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut ContinueStatement,
) {
    visitor.visit_ending(&mut node.ending);
}

pub fn walk_promoted_property_modifier_group_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut PromotedPropertyModifierGroup,
) {
    for item in &mut node.modifiers {
        visitor.visit_promoted_property_modifier(item);
    }
}

pub fn walk_property_modifier_group_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut PropertyModifierGroup,
) {
    for item in &mut node.modifiers {
        visitor.visit_property_modifier(item);
    }
}

pub fn walk_method_modifier_group_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut MethodModifierGroup,
) {
    for item in &mut node.modifiers {
        visitor.visit_method_modifier(item);
    }
}

pub fn walk_class_modifier_group_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut ClassModifierGroup,
) {
    for item in &mut node.modifiers {
        visitor.visit_class_modifier(item);
    }
}

pub fn walk_constant_modifier_group_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut ConstantModifierGroup,
) {
    for item in &mut node.modifiers {
        visitor.visit_constant_modifier(item);
    }
}

pub fn walk_unbraced_namespace_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut UnbracedNamespace,
) {
    visitor.visit_name(&mut node.name);
    for item in &mut node.statements {
        visitor.visit_statement(item);
    }
}

pub fn walk_braced_namespace_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut BracedNamespace,
) {
    if let Some(item) = &mut node.name {
        visitor.visit_name(item);
    }
    visitor.visit_braced_namespace_body(&mut node.body);
}

pub fn walk_braced_namespace_body_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut BracedNamespaceBody,
) {
    for item in &mut node.statements {
        visitor.visit_statement(item);
    }
}

pub fn walk_namespace_statement_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut NamespaceStatement,
) {
    match node {
        NamespaceStatement::Unbraced(inner) => visitor.visit_unbraced_namespace(inner),
        NamespaceStatement::Braced(inner) => visitor.visit_braced_namespace(inner),
        _ => {}
    }
}

pub fn walk_arithmetic_operation_expression_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut ArithmeticOperationExpression,
) {
    visitor.visit_arithmetic_operation_kind(&mut node.kind);
}

pub fn walk_arithmetic_operation_kind_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut ArithmeticOperationKind,
) {
    match node {
        ArithmeticOperationKind::Addition { left, plus, right } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        ArithmeticOperationKind::Subtraction { left, minus, right } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        ArithmeticOperationKind::Multiplication {
            left,
            asterisk,
            right,
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        ArithmeticOperationKind::Division { left, slash, right } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        ArithmeticOperationKind::Modulo {
            left,
            percent,
            right,
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        ArithmeticOperationKind::Exponentiation { left, pow, right } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        ArithmeticOperationKind::Negative { minus, right } => {
            visitor.visit_expression(right);
        }
        ArithmeticOperationKind::Positive { plus, right } => {
            visitor.visit_expression(right);
        }
        ArithmeticOperationKind::PreIncrement { increment, right } => {
            visitor.visit_expression(right);
        }
        ArithmeticOperationKind::PostIncrement { left, increment } => {
            visitor.visit_expression(left);
        }
        ArithmeticOperationKind::PreDecrement { decrement, right } => {
            visitor.visit_expression(right);
        }
        ArithmeticOperationKind::PostDecrement { left, decrement } => {
            visitor.visit_expression(left);
        }
        _ => {}
    }
}

pub fn walk_assignment_operation_expression_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut AssignmentOperationExpression,
) {
    visitor.visit_assignment_operation_kind(&mut node.kind);
}

pub fn walk_assignment_operation_kind_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut AssignmentOperationKind,
) {
    match node {
        AssignmentOperationKind::Assign {
            left,
            equals,
            right,
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        AssignmentOperationKind::Addition {
            left,
            plus_equals,
            right,
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        AssignmentOperationKind::Subtraction {
            left,
            minus_equals,
            right,
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        AssignmentOperationKind::Multiplication {
            left,
            asterisk_equals,
            right,
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        AssignmentOperationKind::Division {
            left,
            slash_equals,
            right,
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        AssignmentOperationKind::Modulo {
            left,
            percent_equals,
            right,
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        AssignmentOperationKind::Exponentiation {
            left,
            pow_equals,
            right,
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        AssignmentOperationKind::Concat {
            left,
            dot_equals,
            right,
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        AssignmentOperationKind::BitwiseAnd {
            left,
            ampersand_equals,
            right,
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        AssignmentOperationKind::BitwiseOr {
            left,
            pipe_equals,
            right,
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        AssignmentOperationKind::BitwiseXor {
            left,
            caret_equals,
            right,
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        AssignmentOperationKind::LeftShift {
            left,
            left_shift_equals,
            right,
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        AssignmentOperationKind::RightShift {
            left,
            right_shift_equals,
            right,
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        AssignmentOperationKind::Coalesce {
            left,
            coalesce_equals,
            right,
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        _ => {}
    }
}

pub fn walk_bitwise_operation_expression_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut BitwiseOperationExpression,
) {
    visitor.visit_bitwise_operation_kind(&mut node.kind);
}

pub fn walk_bitwise_operation_kind_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut BitwiseOperationKind,
) {
    match node {
        BitwiseOperationKind::And { left, and, right } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        BitwiseOperationKind::Or { left, or, right } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        BitwiseOperationKind::Xor { left, xor, right } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        BitwiseOperationKind::LeftShift {
            left,
            left_shift,
            right,
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        BitwiseOperationKind::RightShift {
            left,
            right_shift,
            right,
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        BitwiseOperationKind::Not { not, right } => {
            visitor.visit_expression(right);
        }
        _ => {}
    }
}

pub fn walk_comparison_operation_expression_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut ComparisonOperationExpression,
) {
    visitor.visit_comparison_operation_kind(&mut node.kind);
}

pub fn walk_comparison_operation_kind_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut ComparisonOperationKind,
) {
    match node {
        ComparisonOperationKind::Equal {
            left,
            double_equals,
            right,
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        ComparisonOperationKind::Identical {
            left,
            triple_equals,
            right,
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        ComparisonOperationKind::NotEqual {
            left,
            bang_equals,
            right,
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        ComparisonOperationKind::AngledNotEqual {
            left,
            angled_left_right,
            right,
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        ComparisonOperationKind::NotIdentical {
            left,
            bang_double_equals,
            right,
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        ComparisonOperationKind::LessThan {
            left,
            less_than,
            right,
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        ComparisonOperationKind::GreaterThan {
            left,
            greater_than,
            right,
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        ComparisonOperationKind::LessThanOrEqual {
            left,
            less_than_equals,
            right,
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        ComparisonOperationKind::GreaterThanOrEqual {
            left,
            greater_than_equals,
            right,
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        ComparisonOperationKind::Spaceship {
            left,
            spaceship,
            right,
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        _ => {}
    }
}

pub fn walk_logical_operation_expression_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut LogicalOperationExpression,
) {
    visitor.visit_logical_operation_kind(&mut node.kind);
}

pub fn walk_logical_operation_kind_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut LogicalOperationKind,
) {
    match node {
        LogicalOperationKind::And {
            left,
            double_ampersand,
            right,
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        LogicalOperationKind::Or {
            left,
            double_pipe,
            right,
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        LogicalOperationKind::Not { bang, right } => {
            visitor.visit_expression(right);
        }
        LogicalOperationKind::LogicalAnd { left, and, right } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        LogicalOperationKind::LogicalOr { left, or, right } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        LogicalOperationKind::LogicalXor { left, xor, right } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        _ => {}
    }
}

pub fn walk_name_mut<V: VisitorMut + ?Sized>(visitor: &mut V, node: &mut Name) {
    visitor.visit_name_kind(&mut node.kind);
}

pub fn walk_name_kind_mut<V: VisitorMut + ?Sized>(visitor: &mut V, node: &mut NameKind) {
    match node {
        NameKind::Special(inner) => visitor.visit_special_name(inner),
        NameKind::Unresolved(inner) => visitor.visit_unresolved_name(inner),
        NameKind::Resolved(inner) => visitor.visit_resolved_name(inner),
        _ => {}
    }
}

pub fn walk_special_name_mut<V: VisitorMut + ?Sized>(visitor: &mut V, node: &mut SpecialName) {
    visitor.visit_special_name_kind(&mut node.kind);
}

pub fn walk_property_mut<V: VisitorMut + ?Sized>(visitor: &mut V, node: &mut Property) {
    for item in &mut node.attributes {
        visitor.visit_attribute_group(item);
    }
    visitor.visit_property_modifier_group(&mut node.modifiers);
    if let Some(item) = &mut node.r#type {
        visitor.visit_data_type(item);
    }
    for item in &mut node.entries {
        visitor.visit_property_entry(item);
    }
}

pub fn walk_variable_property_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut VariableProperty,
) {
    for item in &mut node.attributes {
        visitor.visit_attribute_group(item);
    }
    if let Some(item) = &mut node.r#type {
        visitor.visit_data_type(item);
    }
    for item in &mut node.entries {
        visitor.visit_property_entry(item);
    }
}

pub fn walk_property_entry_mut<V: VisitorMut + ?Sized>(visitor: &mut V, node: &mut PropertyEntry) {
    visitor.visit_property_entry_kind(&mut node.kind);
}

pub fn walk_property_entry_kind_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut PropertyEntryKind,
) {
    match node {
        PropertyEntryKind::Uninitialized { variable } => {
            visitor.visit_simple_variable(variable);
        }
        PropertyEntryKind::Initialized {
            variable,
            equals,
            value,
        } => {
            visitor.visit_simple_variable(variable);
            visitor.visit_expression(value);
        }
        _ => {}
    }
}

pub fn walk_trait_body_mut<V: VisitorMut + ?Sized>(visitor: &mut V, node: &mut TraitBody) {
    for item in &mut node.members {
        visitor.visit_classish_member(item);
    }
}

pub fn walk_trait_statement_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut TraitStatement,
) {
    visitor.visit_name(&mut node.name);
    for item in &mut node.attributes {
        visitor.visit_attribute_group(item);
    }
    visitor.visit_trait_body(&mut node.body);
}

pub fn walk_trait_usage_mut<V: VisitorMut + ?Sized>(visitor: &mut V, node: &mut TraitUsage) {
    for item in &mut node.traits {
        visitor.visit_name(item);
    }
    for item in &mut node.adaptations {
        visitor.visit_trait_usage_adaptation(item);
    }
}

pub fn walk_trait_usage_adaptation_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut TraitUsageAdaptation,
) {
    visitor.visit_trait_usage_adaptation_kind(&mut node.kind);
}

pub fn walk_trait_usage_adaptation_kind_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut TraitUsageAdaptationKind,
) {
    match node {
        TraitUsageAdaptationKind::Alias {
            r#trait,
            method,
            alias,
            visibility,
        } => {
            if let Some(item) = r#trait {
                visitor.visit_name(item);
            }
            visitor.visit_simple_identifier(method);
            visitor.visit_simple_identifier(alias);
            if let Some(item) = visibility {
                visitor.visit_visibility_modifier(item);
            }
        }
        TraitUsageAdaptationKind::Visibility {
            r#trait,
            method,
            visibility,
        } => {
            if let Some(item) = r#trait {
                visitor.visit_name(item);
            }
            visitor.visit_simple_identifier(method);
            visitor.visit_visibility_modifier(visibility);
        }
        TraitUsageAdaptationKind::Precedence {
            r#trait,
            method,
            insteadof,
        } => {
            if let Some(item) = r#trait {
                visitor.visit_name(item);
            }
            visitor.visit_simple_identifier(method);
            for item in insteadof {
                visitor.visit_simple_identifier(item);
            }
        }
        _ => {}
    }
}

pub fn walk_catch_type_mut<V: VisitorMut + ?Sized>(visitor: &mut V, node: &mut CatchType) {
    visitor.visit_catch_type_kind(&mut node.kind);
}

pub fn walk_catch_type_kind_mut<V: VisitorMut + ?Sized>(visitor: &mut V, node: &mut CatchTypeKind) {
    match node {
        CatchTypeKind::Identifier { identifier } => {
            visitor.visit_simple_identifier(identifier);
        }
        CatchTypeKind::Union { identifiers } => {
            for item in identifiers {
                visitor.visit_simple_identifier(item);
            }
        }
        _ => {}
    }
}

pub fn walk_try_statement_mut<V: VisitorMut + ?Sized>(visitor: &mut V, node: &mut TryStatement) {
    visitor.visit(&mut node.body);
    for item in &mut node.catches {
        visitor.visit_catch_block(item);
    }
    if let Some(item) = &mut node.finally {
        visitor.visit_finally_block(item);
    }
}

pub fn walk_catch_block_mut<V: VisitorMut + ?Sized>(visitor: &mut V, node: &mut CatchBlock) {
    visitor.visit_catch_type(&mut node.types);
    if let Some(item) = &mut node.var {
        visitor.visit_simple_variable(item);
    }
    visitor.visit(&mut node.body);
}

pub fn walk_finally_block_mut<V: VisitorMut + ?Sized>(visitor: &mut V, node: &mut FinallyBlock) {
    visitor.visit(&mut node.body);
}

pub fn walk_variable_mut<V: VisitorMut + ?Sized>(visitor: &mut V, node: &mut Variable) {
    match node {
        Variable::SimpleVariable(inner) => visitor.visit_simple_variable(inner),
        Variable::VariableVariable(inner) => visitor.visit_variable_variable(inner),
        Variable::BracedVariableVariable(inner) => visitor.visit_braced_variable_variable(inner),
        _ => {}
    }
}

pub fn walk_variable_variable_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut VariableVariable,
) {
    visitor.visit_variable(&mut node.variable);
}

pub fn walk_braced_variable_variable_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut BracedVariableVariable,
) {
    visitor.visit_expression(&mut node.variable);
}

pub fn walk_static_statement_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut StaticStatement,
) {
    for item in &mut node.vars {
        visitor.visit_static_var(item);
    }
}

pub fn walk_switch_statement_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut SwitchStatement,
) {
    visitor.visit_expression(&mut node.condition);
    for item in &mut node.cases {
        visitor.visit_case(item);
    }
}

pub fn walk_echo_statement_mut<V: VisitorMut + ?Sized>(visitor: &mut V, node: &mut EchoStatement) {
    for item in &mut node.values {
        visitor.visit_expression(item);
    }
    visitor.visit_ending(&mut node.ending);
}

pub fn walk_return_statement_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut ReturnStatement,
) {
    if let Some(item) = &mut node.value {
        visitor.visit_expression(item);
    }
    visitor.visit_ending(&mut node.ending);
}

pub fn walk_use_statement_mut<V: VisitorMut + ?Sized>(visitor: &mut V, node: &mut UseStatement) {
    visitor.visit_use_kind(&mut node.kind);
    for item in &mut node.uses {
        visitor.visit_use(item);
    }
}

pub fn walk_group_use_statement_mut<V: VisitorMut + ?Sized>(
    visitor: &mut V,
    node: &mut GroupUseStatement,
) {
    visitor.visit_simple_identifier(&mut node.prefix);
    visitor.visit_use_kind(&mut node.kind);
    for item in &mut node.uses {
        visitor.visit_use(item);
    }
}

pub fn walk_static_var_mut<V: VisitorMut + ?Sized>(visitor: &mut V, node: &mut StaticVar) {
    visitor.visit_variable(&mut node.var);
    if let Some(item) = &mut node.default {
        visitor.visit_expression(item);
    }
}
