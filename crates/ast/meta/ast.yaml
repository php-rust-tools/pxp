# This file contains the AST definition.
# Each node in the AST is defined as an object in this file.
#
# The keys of the object are the field names of the node.
# If the object has an `as` field with a value of Enum, it is an `enum`.
#
# There are some "special" field names used to modify the output.
# as: used to declare the type of the node.
# derive: used to add additional traits to the node.
#
# AST nodes should not be modified directly. All changes should be made in this file.

NodeId: u32
Block: Vec<Statement>

Statement:
  children: [kind]
  kind: StatementKind
  span: Span
  comments: CommentGroup

StatementKind:
  as: Enum
  children: [self]
  FullOpeningTag: Box<FullOpeningTagStatement>
  ShortOpeningTag: Box<ShortOpeningTagStatement>
  EchoOpeningTag: Box<EchoOpeningTagStatement>
  ClosingTag: Box<ClosingTagStatement>
  InlineHtml: Box<InlineHtmlStatement>
  Label: Box<LabelStatement>
  Goto: Box<GotoStatement>
  HaltCompiler: Box<HaltCompilerStatement>
  Static: Box<StaticStatement>
  DoWhile: Box<DoWhileStatement>
  While: Box<WhileStatement>
  For: Box<ForStatement>
  Foreach: Box<ForeachStatement>
  Break: Box<BreakStatement>
  Continue: Box<ContinueStatement>
  Constant: Box<ConstantStatement>
  Function: Box<FunctionStatement>
  Class: Box<ClassStatement>
  Trait: Box<TraitStatement>
  Interface: Box<InterfaceStatement>
  If: Box<IfStatement>
  Switch: Box<SwitchStatement>
  Echo: Box<EchoStatement>
  Expression: Box<ExpressionStatement>
  Return: Box<ReturnStatement>
  Namespace: Box<NamespaceStatement>
  Use: Box<UseStatement>
  GroupUse: Box<GroupUseStatement>
  Comment: Box<CommentStatement>
  Try: Box<TryStatement>
  UnitEnum: Box<UnitEnumStatement>
  BackedEnum: Box<BackedEnumStatement>
  Block: Box<BlockStatement>
  Global: Box<GlobalStatement>
  Declare: Box<DeclareStatement>
  Noop: Span

Expression:
  children: [kind]
  kind: ExpressionKind
  span: Span
  comments: CommentGroup

ExpressionKind:
  as: Enum
  children: [self]
  Missing: MissingExpression
  Eval: Box<EvalExpression>
  Empty: Box<EmptyExpression>
  Die: Box<DieExpression>
  Exit: Box<ExitExpression>
  Isset: Box<IssetExpression>
  Unset: Box<UnsetExpression>
  Print: Box<PrintExpression>
  Literal: Box<Literal>
  ArithmeticOperation: Box<ArithmeticOperationExpression>
  AssignmentOperation: Box<AssignmentOperationExpression>
  BitwiseOperation: Box<BitwiseOperationExpression>
  ComparisonOperation: Box<ComparisonOperationExpression>
  LogicalOperation: Box<LogicalOperationExpression>
  Concat: Box<ConcatExpression>
  Instanceof: Box<InstanceofExpression>
  Reference: Box<ReferenceExpression>
  Parenthesized: Box<ParenthesizedExpression>
  ErrorSuppress: Box<ErrorSuppressExpression>
  Identifier: Box<Identifier>
  Variable: Box<Variable>
  Include: Box<IncludeExpression>
  IncludeOnce: Box<IncludeOnceExpression>
  Require: Box<RequireExpression>
  RequireOnce: Box<RequireOnceExpression>
  FunctionCall: Box<FunctionCallExpression>
  FunctionClosureCreation: Box<FunctionClosureCreationExpression>
  MethodCall: Box<MethodCallExpression>
  MethodClosureCreation: Box<MethodClosureCreationExpression>
  NullsafeMethodCall: Box<NullsafeMethodCallExpression>
  StaticMethodCall: Box<StaticMethodCallExpression>
  StaticVariableMethodCall: Box<StaticVariableMethodCallExpression>
  StaticMethodClosureCreation: Box<StaticMethodClosureCreationExpression>
  StaticVariableMethodClosureCreation: Box<StaticVariableMethodClosureCreationExpression>
  PropertyFetch: Box<PropertyFetchExpression>
  NullsafePropertyFetch: Box<NullsafePropertyFetchExpression>
  StaticPropertyFetch: Box<StaticPropertyFetchExpression>
  ConstantFetch: Box<ConstantFetchExpression>
  Static: Box<StaticExpression>
  Self_: Box<SelfExpression>
  Parent: Box<ParentExpression>
  ShortArray: Box<ShortArrayExpression>
  Array: Box<ArrayExpression>
  List: Box<ListExpression>
  Closure: Box<ClosureExpression>
  ArrowFunction: Box<ArrowFunctionExpression>
  New: Box<NewExpression>
  InterpolatedString: Box<InterpolatedStringExpression>
  Heredoc: Box<HeredocExpression>
  Nowdoc: Box<NowdocExpression>
  ShellExec: Box<ShellExecExpression>
  AnonymousClass: Box<AnonymousClassExpression>
  Bool: Box<BoolExpression>
  ArrayIndex: Box<ArrayIndexExpression>
  "Null": Span
  MagicConstant: Box<MagicConstantExpression>
  ShortTernary: Box<ShortTernaryExpression>
  Ternary: Box<TernaryExpression>
  Coalesce: Box<CoalesceExpression>
  Clone: Box<CloneExpression>
  Match: Box<MatchExpression>
  Throw: Box<ThrowExpression>
  Yield: Box<YieldExpression>
  YieldFrom: Box<YieldFromExpression>
  Cast: Box<CastExpression>
  Name: Box<Name>
  Noop: Span

MissingExpression:
  span: Span

StaticExpression:
  span: Span

SelfExpression:
  span: Span

ParentExpression:
  span: Span

CommentStatement:
  span: Span
  comment: Comment

InlineHtmlStatement:
  span: Span
  html: OwnedToken

FullOpeningTagStatement:
  span: Span

ShortOpeningTagStatement:
  span: Span

EchoOpeningTagStatement:
  span: Span

ClosingTagStatement:
  span: Span

ExpressionStatement:
  children: [expression]
  span: Span
  expression: Expression
  ending: Ending

GlobalStatement:
  children: [variables]
  span: Span
  global: Span
  variables: Vec<Variable>
  semicolon: Span

BlockStatement:
  children: [statements]
  span: Span
  left_brace: Span
  statements: Vec<Statement>
  right_brace: Span

CastKind:
  node: false
  as: Enum
  Int: Span
  Bool: Span
  Float: Span
  String: Span
  Array: Span
  Object: Span
  Unset: Span

Case:
  children: [condition?, body]
  span: Span
  condition: Option<Expression>
  body: Block

Use:
  children: [name, alias?]
  span: Span
  name: Name
  alias: Option<SimpleIdentifier>
  kind: UseKind

UseKind:
  node: false
  as: Enum
  derive: Hash, Copy
  Normal: ''
  Function: ''
  Const: ''

EvalExpression:
  children: [argument]
  span: Span
  eval: Span
  argument: Box<SingleArgument>

EmptyExpression:
  children: [argument]
  span: Span
  empty: Span
  argument: Box<SingleArgument>

DieExpression:
  children: [argument?]
  span: Span
  die: Span
  argument: Option<Box<SingleArgument>>

ExitExpression:
  children: [argument?]
  span: Span
  exit: Span
  argument: Option<Box<SingleArgument>>

IssetExpression:
  children: [arguments]
  span: Span
  isset: Span
  arguments: ArgumentList

UnsetExpression:
  children: [arguments]
  span: Span
  unset: Span
  arguments: ArgumentList

PrintExpression:
  children: [value?, argument?]
  span: Span
  print: Span
  value: Option<Box<Expression>>
  argument: Option<Box<SingleArgument>>

ConcatExpression:
  children: [left, right]
  span: Span
  left: Box<Expression>
  dot: Span
  right: Box<Expression>

InstanceofExpression:
  children: [left, right]
  span: Span
  left: Box<Expression>
  instanceof: Span
  right: Box<Expression>

ReferenceExpression:
  children: [right]
  span: Span
  ampersand: Span
  right: Box<Expression>

ParenthesizedExpression:
  children: [expr]
  span: Span
  start: Span
  expr: Box<Expression>
  end: Span

ErrorSuppressExpression:
  children: [expr]
  span: Span
  at: Span
  expr: Box<Expression>

IncludeExpression:
  children: [path]
  span: Span
  include: Span
  path: Box<Expression>

IncludeOnceExpression:
  children: [path]
  span: Span
  include_once: Span
  path: Box<Expression>

RequireExpression:
  children: [path]
  span: Span
  require: Span
  path: Box<Expression>

RequireOnceExpression:
  children: [path]
  span: Span
  require_once: Span
  path: Box<Expression>

FunctionCallExpression:
  children: [target, arguments]
  span: Span
  target: Box<Expression>
  arguments: ArgumentList

FunctionClosureCreationExpression:
  children: [target, placeholder]
  span: Span
  target: Box<Expression>
  placeholder: ArgumentPlaceholder

MethodCallExpression:
  children: [target, method, arguments]
  span: Span
  target: Box<Expression>
  arrow: Span
  method: Box<Expression>
  arguments: ArgumentList

MethodClosureCreationExpression:
  children: [target, method]
  span: Span
  target: Box<Expression>
  arrow: Span
  method: Box<Expression>
  placeholder: ArgumentPlaceholder

NullsafeMethodCallExpression:
  children: [target, method, arguments]
  span: Span
  target: Box<Expression>
  question_arrow: Span
  method: Box<Expression>
  arguments: ArgumentList

StaticMethodCallExpression:
  children: [target, method, arguments]
  span: Span
  target: Box<Expression>
  double_colon: Span
  method: Identifier
  arguments: ArgumentList

StaticVariableMethodCallExpression:
  children: [target, method, arguments]
  span: Span
  target: Box<Expression>
  double_colon: Span
  method: Variable
  arguments: ArgumentList

StaticMethodClosureCreationExpression:
  children: [target, method]
  span: Span
  target: Box<Expression>
  double_colon: Span
  method: Identifier
  placeholder: ArgumentPlaceholder

StaticVariableMethodClosureCreationExpression:
  children: [target, method]
  span: Span
  target: Box<Expression>
  double_colon: Span
  method: Variable
  placeholder: ArgumentPlaceholder

PropertyFetchExpression:
  children: [target, property]
  span: Span
  target: Box<Expression>
  arrow: Span
  property: Box<Expression>

NullsafePropertyFetchExpression:
  children: [target, property]
  span: Span
  target: Box<Expression>
  question_arrow: Span
  property: Box<Expression>

StaticPropertyFetchExpression:
  children: [target, property]
  span: Span
  target: Box<Expression>
  double_colon: Span
  property: Variable

ConstantFetchExpression:
  children: [target, constant]
  span: Span
  target: Box<Expression>
  double_colon: Span
  constant: Identifier

ShortArrayExpression:
  children: [items]
  span: Span
  start: Span
  items: CommaSeparated<ArrayItem>
  end: Span

ArrayExpression:
  children: [items]
  span: Span
  array: Span
  start: Span
  items: CommaSeparated<ArrayItem>
  end: Span

ListExpression:
  children: [items]
  span: Span
  list: Span
  start: Span
  items: Vec<ListEntry>
  end: Span

NewExpression:
  children: [target, arguments?]
  span: Span
  new: Span
  target: Box<Expression>
  arguments: Option<ArgumentList>

InterpolatedStringExpression:
  children: [parts]
  span: Span
  parts: Vec<StringPart>

HeredocExpression:
  children: [parts]
  span: Span
  label: ByteString
  parts: Vec<StringPart>

NowdocExpression:
  span: Span
  label: OwnedToken
  value: OwnedToken

ShellExecExpression:
  children: [parts]
  span: Span
  parts: Vec<StringPart>

BoolExpression:
  span: Span
  value: OwnedToken

ArrayIndexExpression:
  children: [array, index?]
  span: Span
  array: Box<Expression>
  left_bracket: Span
  index: Option<Box<Expression>>
  right_bracket: Span

ShortTernaryExpression:
  children: [condition, r#else]
  span: Span
  condition: Box<Expression>
  question_colon: Span
  r#else: Box<Expression>

TernaryExpression:
  children: [condition, then, r#else]
  span: Span
  condition: Box<Expression>
  question: Span
  then: Box<Expression>
  colon: Span
  r#else: Box<Expression>

CoalesceExpression:
  children: [lhs, rhs]
  span: Span
  lhs: Box<Expression>
  double_question: Span
  rhs: Box<Expression>

CloneExpression:
  children: [target]
  span: Span
  clone: Span
  target: Box<Expression>

MatchExpression:
  children: [condition, arms, default?]
  span: Span
  keyword: Span
  left_parenthesis: Span
  condition: Box<Expression>
  right_parenthesis: Span
  left_brace: Span
  default: Option<Box<DefaultMatchArm>>
  arms: Vec<MatchArm>
  right_brace: Span

ThrowExpression:
  children: [value]
  span: Span
  value: Box<Expression>

YieldExpression:
  children: [key?, value?]
  span: Span
  r#yield: Span
  key: Option<Box<Expression>>
  value: Option<Box<Expression>>

YieldFromExpression:
  children: [value]
  span: Span
  r#yield: Span
  from: Span
  value: Box<Expression>

CastExpression:
  children: [value]
  span: Span
  kind: CastKind
  value: Box<Expression>

DefaultMatchArm:
  children: [body]
  span: Span
  keyword: Span
  double_arrow: Span
  body: Expression

MatchArm:
  children: [conditions, body]
  span: Span
  conditions: Vec<Expression>
  arrow: Span
  body: Expression

MagicConstantExpression:
  span: Span
  kind: MagicConstantKind

MagicConstantKind:
  as: Enum
  node: false
  Directory: ""
  File: ""
  Line: ""
  Function: ""
  Class: ""
  Method: ""
  Namespace: ""
  Trait: ""
  CompilerHaltOffset: ""

StringPart:
  children: [self]
  as: Enum
  Literal: LiteralStringPart
  Expression: ExpressionStringPart

LiteralStringPart:
  span: Span
  value: ByteString

ExpressionStringPart:
  children: [expression]
  span: Span
  expression: Box<Expression>

ArrayItem:
  children: [self]
  as: Enum
  Skipped: Span
  Value: ArrayItemValue
  ReferencedValue: ArrayItemReferencedValue
  SpreadValue: ArrayItemSpreadValue
  KeyValue: ArrayItemKeyValue
  ReferencedKeyValue: ArrayItemReferencedKeyValue

ArrayItemValue:
  children: [value]
  span: Span
  value: Expression

ArrayItemReferencedValue:
  children: [value]
  span: Span
  ampersand: Span
  value: Expression

ArrayItemSpreadValue:
  children: [value]
  span: Span
  ellipsis: Span
  value: Expression

ArrayItemKeyValue:
  children: [key, value]
  span: Span
  key: Expression
  double_arrow: Span
  value: Expression

ArrayItemReferencedKeyValue:
  children: [key, value]
  span: Span
  key: Expression
  double_arrow: Span
  ampersand: Span
  value: Expression

ListEntry:
  children: [self]
  as: Enum
  Skipped: Span
  Value: ListEntryValue
  KeyValue: ListEntryKeyValue

ListEntryValue:
  children: [value]
  span: Span
  value: Expression

ListEntryKeyValue:
  children: [key, value]
  span: Span
  key: Expression
  double_arrow: Span
  value: Expression

PositionalArgument:
  children: [value]
  span: Span
  comments: CommentGroup
  ellipsis: Option<Span>
  value: Expression

NamedArgument:
  children: [name, value]
  span: Span
  comments: CommentGroup
  name: SimpleIdentifier
  colon: Span
  ellipsis: Option<Span>
  value: Expression

Argument:
  children: [self]
  as: Enum
  Positional: PositionalArgument
  Named: NamedArgument

ArgumentList:
  children: [arguments]
  span: Span
  comments: CommentGroup
  left_parenthesis: Span
  arguments: Vec<Argument>
  right_parenthesis: Span

SingleArgument:
  children: [argument?]
  span: Span
  comments: CommentGroup
  left_parenthesis: Span
  argument: Option<Argument>
  right_parenthesis: Span

ArgumentPlaceholder:
  span: Span
  comments: CommentGroup
  left_parenthesis: Span
  ellipsis: Span
  right_parenthesis: Span

Attribute:
  children: [name, arguments?]
  span: Span
  name: Name
  arguments: Option<ArgumentList>

AttributeGroup:
  children: [members]
  span: Span
  members: Vec<Attribute>

ClassBody:
  children: [members]
  span: Span
  left_brace: Span
  members: Vec<ClassishMember>
  right_brace: Span

ClassStatement:
  children: [name, extends?, implements?, body]
  span: Span
  attributes: Vec<AttributeGroup>
  modifiers: ClassModifierGroup
  class: Span
  name: Name
  extends: Option<ClassExtends>
  implements: Option<ClassImplements>
  body: ClassBody

AnonymousClassBody:
  children: [members]
  span: Span
  left_brace: Span
  members: Vec<ClassishMember>
  right_brace: Span

AnonymousClassExpression:
  children: [extends?, implements?, body]
  span: Span
  attributes: Vec<AttributeGroup>
  class: Span
  extends: Option<ClassExtends>
  implements: Option<ClassImplements>
  body: Box<AnonymousClassBody>

ClassExtends:
  children: [parent]
  span: Span
  extends: Span
  parent: Name

ClassImplements:
  children: [interfaces]
  span: Span
  implements: Span
  interfaces: CommaSeparated<Name>

ClassishMember:
  children: [self]
  as: Enum
  Constant: ClassishConstant
  TraitUsage: TraitUsage
  Property: Property
  Method: Method
  Missing: MissingClassishMember

Method:
  children: [attributes, name, parameters, return_type?, body]
  span: Span
  comments: CommentGroup
  attributes: Vec<AttributeGroup>
  modifiers: MethodModifierGroup
  function: Span
  ampersand: Option<Span>
  name: SimpleIdentifier
  parameters: MethodParameterList
  return_type: Option<ReturnType>
  body: MethodBody

MethodBody:
  children: [kind]
  span: Span
  kind: MethodBodyKind

MethodBodyKind:
  as: Enum
  children: [self]
  Abstract: AbstractMethodBody
  Concrete: ConcreteMethodBody
  Missing: MissingMethodBody

MissingMethodBody:
  span: Span

AbstractMethodBody:
  span: Span
  semicolon: Span

ConcreteMethodBody:
  children: [statements]
  span: Span
  left_brace: Span
  statements: Vec<Statement>
  right_brace: Span

MethodParameterList:
  children: [parameters]
  span: Span
  left_parenthesis: Span
  parameters: CommaSeparated<MethodParameter>
  right_parenthesis: Span

MethodParameter:
  children: [name, data_type?, default?]
  span: Span
  modifiers: Option<PromotedPropertyModifierGroup>
  name: SimpleVariable
  attributes: Vec<AttributeGroup>
  data_type: Option<DataType>
  ellipsis: Option<Span>
  default: Option<Expression>
  ampersand: Option<Span>

MissingClassishMember:
  span: Span

ConstantEntry:
  children: [name, value]
  span: Span
  name: Name
  equals: Span
  value: Expression

ClassishConstantEntry:
  children: [name, value]
  span: Span
  name: SimpleIdentifier
  equals: Span
  value: Expression

ConstantStatement:
  children: [entries]
  span: Span
  comments: CommentGroup
  r#const: Span
  entries: Vec<ConstantEntry>
  semicolon: Span

ClassishConstant:
  children: [attributes, data_type?, entries]
  span: Span
  comments: CommentGroup
  attributes: Vec<AttributeGroup>
  modifiers: ConstantModifierGroup
  r#const: Span
  data_type: Option<DataType>
  entries: Vec<ClassishConstantEntry>
  semicolon: Span

IfStatement:
  children: [condition, body]
  span: Span
  r#if: Span
  left_parenthesis: Span
  condition: Expression
  right_parenthesis: Span
  body: IfStatementBody

IfStatementBody:
  children: [self]
  as: Enum
  Statement: IfStatementBodyStatement
  Block: IfStatementBodyBlock

IfStatementBodyStatement:
  children: [statement, elseifs, r#else?]
  span: Span
  statement: Box<Statement>
  elseifs: Vec<IfStatementElseIf>
  r#else: Option<IfStatementElse>

IfStatementBodyBlock:
  children: [statements, elseifs, r#else?]
  span: Span
  colon: Span
  statements: Vec<Statement>
  elseifs: Vec<IfStatementElseIfBlock>
  r#else: Option<Box<IfStatementElseBlock>>
  endif: Span
  ending: Ending

IfStatementElseIf:
  children: [condition, statement]
  span: Span
  elseif: Span
  left_parenthesis: Span
  condition: Expression
  right_parenthesis: Span
  statement: Box<Statement>

IfStatementElse:
  children: [statement]
  span: Span
  r#else: Span
  statement: Box<Statement>

IfStatementElseIfBlock:
  children: [condition, statements]
  span: Span
  elseif: Span
  left_parenthesis: Span
  condition: Expression
  right_parenthesis: Span
  colon: Span
  statements: Vec<Statement>

IfStatementElseBlock:
  children: [statements]
  span: Span
  r#else: Span
  colon: Span
  statements: Vec<Statement>

DataType:
  kind: Type<Name>
  span: Span

DeclareEntry:
  children: [key, value]
  span: Span
  key: SimpleIdentifier
  equals: Span
  value: Literal

DeclareEntryGroup:
  children: [entries]
  span: Span
  left_parenthesis: Span
  right_parenthesis: Span
  entries: Vec<DeclareEntry>

DeclareBody:
  children: [self]
  as: Enum
  Noop: DeclareBodyNoop
  Braced: DeclareBodyBraced
  Expression: DeclareBodyExpression
  Block: DeclareBodyBlock

DeclareBodyNoop:
  span: Span
  semicolon: Span

DeclareBodyBraced:
  children: [statements]
  span: Span
  left_brace: Span
  statements: Vec<Statement>
  right_brace: Span

DeclareBodyExpression:
  children: [expression]
  span: Span
  expression: Expression
  semicolon: Span

DeclareBodyBlock:
  children: [statements]
  span: Span
  colon: Span
  statements: Vec<Statement>
  enddeclare: Span
  semicolon: Span

DeclareStatement:
  children: [entries, body]
  span: Span
  declare: Span
  entries: DeclareEntryGroup
  body: DeclareBody

UnitEnumCase:
  children: [attributes, name]
  span: Span
  attributes: Vec<AttributeGroup>
  start: Span
  name: SimpleIdentifier
  end: Span

UnitEnumMember:
  children: [self]
  as: Enum
  Case: UnitEnumCase
  Classish: ClassishMember

UnitEnumBody:
  children: [members]
  span: Span
  left_brace: Span
  members: Vec<UnitEnumMember>
  right_brace: Span

UnitEnumStatement:
  children: [name, implements, body]
  span: Span
  attributes: Vec<AttributeGroup>
  r#enum: Span
  name: Name
  implements: Vec<Name>
  body: UnitEnumBody

BackedEnumCase:
  children: [attributes, name, value]
  span: Span
  attributes: Vec<AttributeGroup>
  case: Span
  name: SimpleIdentifier
  equals: Span
  value: Expression
  semicolon: Span

BackedEnumMember:
  children: [self]
  as: Enum
  Case: BackedEnumCase
  Classish: ClassishMember

BackedEnumBody:
  children: [members]
  span: Span
  left_brace: Span
  members: Vec<BackedEnumMember>
  right_brace: Span

BackedEnumStatement:
  children: [attributes, name, implements, body]
  span: Span
  attributes: Vec<AttributeGroup>
  r#enum: Span
  name: Name
  colon: Span
  backed_type: BackedEnumType
  implements: Vec<Name>
  body: BackedEnumBody

BackedEnumType:
  as: Enum
  node: false
  String: Span
  Int: Span
  Invalid: ''

ReturnType:
  children: [data_type]
  span: Span
  colon: Span
  data_type: DataType

FunctionParameter:
  children: [name, data_type?, default?]
  span: Span
  comments: CommentGroup
  name: SimpleVariable
  attributes: Vec<AttributeGroup>
  data_type: Option<DataType>
  ellipsis: Option<Span>
  default: Option<Expression>
  ampersand: Option<Span>

FunctionParameterList:
  children: [parameters]
  span: Span
  comments: CommentGroup
  left_parenthesis: Span
  parameters: CommaSeparated<FunctionParameter>
  right_parenthesis: Span

FunctionBody:
  children: [statements]
  span: Span
  comments: CommentGroup
  left_brace: Span
  statements: Vec<Statement>
  right_brace: Span

FunctionStatement:
  children: [attributes, name, parameters, return_type?, body]
  span: Span
  comments: CommentGroup
  attributes: Vec<AttributeGroup>
  function: Span
  ampersand: Option<Span>
  name: Name
  parameters: FunctionParameterList
  return_type: Option<ReturnType>
  body: FunctionBody

ClosureUseVariable:
  children: [variable]
  span: Span
  comments: CommentGroup
  ampersand: Option<Span>
  variable: SimpleVariable

ClosureUse:
  children: [variables]
  span: Span
  comments: CommentGroup
  r#use: Span
  left_parenthesis: Span
  variables: CommaSeparated<ClosureUseVariable>
  right_parenthesis: Span

ClosureExpression:
  children: [attributes, parameters, uses?, return_type?, body]
  span: Span
  comments: CommentGroup
  attributes: Vec<AttributeGroup>
  r#static: Option<Span>
  function: Span
  ampersand: Option<Span>
  parameters: FunctionParameterList
  uses: Option<ClosureUse>
  return_type: Option<ReturnType>
  body: FunctionBody

ArrowFunctionExpression:
  children: [attributes, parameters, return_type?, body]
  span: Span
  comments: CommentGroup
  r#static: Option<Span>
  ampersand: Option<Span>
  r#fn: Span
  attributes: Vec<AttributeGroup>
  parameters: FunctionParameterList
  return_type: Option<ReturnType>
  double_arrow: Span
  body: Box<Expression>

LabelStatement:
  children: [label]
  span: Span
  comments: CommentGroup
  label: SimpleIdentifier
  colon: Span

GotoStatement:
  children: [label]
  span: Span
  comments: CommentGroup
  keyword: Span
  label: SimpleIdentifier
  semicolon: Span

Identifier:
  children: [self]
  as: Enum
  SimpleIdentifier: SimpleIdentifier
  DynamicIdentifier: DynamicIdentifier

SimpleIdentifier:
  symbol: ByteString
  span: Span

DynamicIdentifier:
  children: [expr]
  span: Span
  expr: Box<Expression>

InterfaceExtends:
  children: [parents]
  span: Span
  extends: Span
  parents: CommaSeparated<Name>

InterfaceBody:
  children: [members]
  span: Span
  left_brace: Span
  members: Vec<ClassishMember>
  right_brace: Span

InterfaceStatement:
  children: [attributes, name, extends?, body]
  span: Span
  attributes: Vec<AttributeGroup>
  interface: Span
  name: Name
  extends: Option<InterfaceExtends>
  body: InterfaceBody

Literal:
  span: Span
  kind: LiteralKind
  token: OwnedToken

LiteralKind:
  as: Enum
  node: false
  Integer: ""
  Float: ""
  String: ""
  Missing: ""

ForeachStatement:
  children: [iterator, body]
  span: Span
  foreach: Span
  left_parenthesis: Span
  iterator: ForeachStatementIterator
  right_parenthesis: Span
  body: ForeachStatementBody

ForeachStatementIterator:
  children: [self]
  as: Enum
  Value: ForeachStatementIteratorValue
  KeyAndValue: ForeachStatementIteratorKeyAndValue

ForeachStatementIteratorValue:
  children: [expression, value]
  span: Span
  expression: Expression
  r#as: Span
  ampersand: Option<Span>
  value: Expression

ForeachStatementIteratorKeyAndValue:
  children: [expression, key, value]
  span: Span
  expression: Expression
  r#as: Span
  ampersand: Option<Span>
  key: Expression
  double_arrow: Span
  value: Expression

ForeachStatementBody:
  as: Enum
  Statement: ForeachStatementBodyStatement
  Block: ForeachStatementBodyBlock
  
ForeachStatementBodyStatement:
  children: [statement]
  span: Span
  statement: Box<Statement>

ForeachStatementBodyBlock:
  children: [statements]
  span: Span
  colon: Span
  statements: Vec<Statement>
  endforeach: Span
  ending: Ending

ForStatement:
  children: [iterator, body]
  span: Span
  r#for: Span
  left_parenthesis: Span
  iterator: ForStatementIterator
  right_parenthesis: Span
  body: ForStatementBody

ForStatementIterator:
  children: [initializations, conditions, r#loop]
  span: Span
  initializations: CommaSeparated<Expression>
  initializations_semicolon: Span
  conditions: CommaSeparated<Expression>
  conditions_semicolon: Span
  r#loop: CommaSeparated<Expression>

ForStatementBody:
  as: Enum
  Statement: ForStatementBodyStatement
  Block: ForStatementBodyBlock

ForStatementBodyStatement:
  children: [statement]
  span: Span
  statement: Box<Statement>

ForStatementBodyBlock:
  children: [statements]
  span: Span
  colon: Span
  statements: Vec<Statement>
  endfor: Span
  ending: Ending

DoWhileStatement:
  children: [condition, body]
  span: Span
  r#do: Span
  body: Box<Statement>
  r#while: Span
  left_parenthesis: Span
  condition: Expression
  right_parenthesis: Span
  semicolon: Span

WhileStatement:
  children: [condition, body]
  span: Span
  r#while: Span
  left_parenthesis: Span
  condition: Expression
  right_parenthesis: Span
  body: WhileStatementBody

WhileStatementBody:
  children: [self]
  as: Enum
  Statement: WhileStatementBodyStatement
  Block: WhileStatementBodyBlock
  
WhileStatementBodyStatement:
  children: [statement]
  span: Span
  statement: Box<Statement>

WhileStatementBodyBlock:
  children: [statements]
  span: Span
  colon: Span
  statements: Vec<Statement>
  endwhile: Span
  ending: Ending

Level:
  as: Enum
  Literal: LiteralLevel
  Parenthesized: ParenthesizedLevel

LiteralLevel:
  literal: Literal

ParenthesizedLevel:
  children: [level]
  span: Span
  left_parenthesis: Span
  level: Box<Level>
  right_parenthesis: Span

BreakStatement:
  children: [level?]
  span: Span
  r#break: Span
  level: Option<Level>
  ending: Ending

ContinueStatement:
  children: [level?]
  span: Span
  r#continue: Span
  level: Option<Level>
  ending: Ending

VisibilityModifier:
  as: Enum
  node: false
  Public: Span
  Protected: Span
  Private: Span

PromotedPropertyModifier:
  as: Enum
  node: false
  Public: Span
  Protected: Span
  Private: Span
  PublicSet: Span
  ProtectedSet: Span
  PrivateSet: Span
  Readonly: Span

PromotedPropertyModifierGroup:
  derive: Default
  span: Span
  modifiers: Vec<PromotedPropertyModifier>

PropertyModifier:
  as: Enum
  node: false
  Public: Span
  Protected: Span
  Private: Span
  PublicSet: Span
  ProtectedSet: Span
  PrivateSet: Span
  Static: Span
  Readonly: Span

PropertyModifierGroup:
  derive: Default
  span: Span
  modifiers: Vec<PropertyModifier>

MethodModifier:
  as: Enum
  node: false
  Public: Span
  Protected: Span
  Private: Span
  Static: Span
  Abstract: Span
  Final: Span

MethodModifierGroup:
  derive: Default
  span: Span
  modifiers: Vec<MethodModifier>

ClassModifier:
  as: Enum
  node: false
  Abstract: Span
  Final: Span
  Readonly: Span

ClassModifierGroup:
  derive: Default
  span: Span
  modifiers: Vec<ClassModifier>

ConstantModifier:
  as: Enum
  node: false
  Public: Span
  Protected: Span
  Private: Span
  Final: Span

ConstantModifierGroup:
  span: Span
  modifiers: Vec<ConstantModifier>

UnbracedNamespace:
  children: [statements]
  span: Span
  start: Span
  name: SimpleIdentifier
  end: Span
  statements: Vec<Statement>

BracedNamespace:
  children: [name?, body]
  span: Span
  namespace: Span
  name: Option<SimpleIdentifier>
  body: BracedNamespaceBody

BracedNamespaceBody:
  children: [statements]
  span: Span
  start: Span
  end: Span
  statements: Vec<Statement>

NamespaceStatement:
  children: [self]
  as: Enum
  Unbraced: UnbracedNamespace
  Braced: BracedNamespace

ArithmeticOperationExpression:
  children: [kind]
  span: Span
  kind: ArithmeticOperationKind

ArithmeticOperationKind:
  children: [self.left!, self.right!]
  as: Enum
  Addition:
    left: Box<Expression>
    plus: Span
    right: Box<Expression>
  Subtraction:
    left: Box<Expression>
    minus: Span
    right: Box<Expression>
  Multiplication:
    left: Box<Expression>
    asterisk: Span
    right: Box<Expression>
  Division:
    left: Box<Expression>
    slash: Span
    right: Box<Expression>
  Modulo:
    left: Box<Expression>
    percent: Span
    right: Box<Expression>
  Exponentiation:
    left: Box<Expression>
    pow: Span
    right: Box<Expression>
  Negative:
    minus: Span
    right: Box<Expression>
  Positive:
    plus: Span
    right: Box<Expression>
  PreIncrement:
    increment: Span
    right: Box<Expression>
  PostIncrement:
    left: Box<Expression>
    increment: Span
  PreDecrement:
    decrement: Span
    right: Box<Expression>
  PostDecrement:
    left: Box<Expression>
    decrement: Span

AssignmentOperationExpression:
  children: [kind]
  span: Span
  kind: AssignmentOperationKind

AssignmentOperationKind:
  children: [self.left!, self.right!]
  as: Enum
  Assign:
    left: Box<Expression>
    equals: Span
    right: Box<Expression>
  Addition:
    left: Box<Expression>
    plus_equals: Span
    right: Box<Expression>
  Subtraction:
    left: Box<Expression>
    minus_equals: Span
    right: Box<Expression>
  Multiplication:
    left: Box<Expression>
    asterisk_equals: Span
    right: Box<Expression>
  Division:
    left: Box<Expression>
    slash_equals: Span
    right: Box<Expression>
  Modulo:
    left: Box<Expression>
    percent_equals: Span
    right: Box<Expression>
  Exponentiation:
    left: Box<Expression>
    pow_equals: Span
    right: Box<Expression>
  Concat:
    left: Box<Expression>
    dot_equals: Span
    right: Box<Expression>
  BitwiseAnd:
    left: Box<Expression>
    ampersand_equals: Span
    right: Box<Expression>
  BitwiseOr:
    left: Box<Expression>
    pipe_equals: Span
    right: Box<Expression>
  BitwiseXor:
    left: Box<Expression>
    caret_equals: Span
    right: Box<Expression>
  LeftShift:
    left: Box<Expression>
    left_shift_equals: Span
    right: Box<Expression>
  RightShift:
    left: Box<Expression>
    right_shift_equals: Span
    right: Box<Expression>
  Coalesce:
    left: Box<Expression>
    coalesce_equals: Span
    right: Box<Expression>

BitwiseOperationExpression:
  children: [kind]
  span: Span
  kind: BitwiseOperationKind

BitwiseOperationKind:
  children: [self.left!, self.right!]
  as: Enum
  And:
    left: Box<Expression>
    and: Span
    right: Box<Expression>
  Or:
    left: Box<Expression>
    or: Span
    right: Box<Expression>
  Xor:
    left: Box<Expression>
    xor: Span
    right: Box<Expression>
  LeftShift:
    left: Box<Expression>
    left_shift: Span
    right: Box<Expression>
  RightShift:
    left: Box<Expression>
    right_shift: Span
    right: Box<Expression>
  Not:
    not: Span
    right: Box<Expression>

ComparisonOperationExpression:
  children: [kind]
  span: Span
  kind: ComparisonOperationKind

ComparisonOperationKind:
  children: [self.left!, self.right!]
  as: Enum
  Equal:
    left: Box<Expression>
    double_equals: Span
    right: Box<Expression>
  Identical:
    left: Box<Expression>
    triple_equals: Span
    right: Box<Expression>
  NotEqual:
    left: Box<Expression>
    bang_equals: Span
    right: Box<Expression>
  AngledNotEqual:
    left: Box<Expression>
    angled_left_right: Span
    right: Box<Expression>
  NotIdentical:
    left: Box<Expression>
    bang_double_equals: Span
    right: Box<Expression>
  LessThan:
    left: Box<Expression>
    less_than: Span
    right: Box<Expression>
  GreaterThan:
    left: Box<Expression>
    greater_than: Span
    right: Box<Expression>
  LessThanOrEqual:
    left: Box<Expression>
    less_than_equals: Span
    right: Box<Expression>
  GreaterThanOrEqual:
    left: Box<Expression>
    greater_than_equals: Span
    right: Box<Expression>
  Spaceship:
    left: Box<Expression>
    spaceship: Span
    right: Box<Expression>

LogicalOperationExpression:
  children: [kind]
  span: Span
  kind: LogicalOperationKind

LogicalOperationKind:
  children: [self.left!, self.right!]
  as: Enum
  And:
    left: Box<Expression>
    double_ampersand: Span
    right: Box<Expression>
  Or:
    left: Box<Expression>
    double_pipe: Span
    right: Box<Expression>
  Not:
    bang: Span
    right: Box<Expression>
  LogicalAnd:
    left: Box<Expression>
    and: Span
    right: Box<Expression>
  LogicalOr:
    left: Box<Expression>
    or: Span
    right: Box<Expression>
  LogicalXor:
    left: Box<Expression>
    xor: Span
    right: Box<Expression>

Name:
  kind: NameKind
  span: Span

NameKind:
  children: [self]
  as: Enum
  Special: SpecialName
  Unresolved: UnresolvedName
  Resolved: ResolvedName

SpecialName:
  span: Span
  kind: SpecialNameKind
  symbol: ByteString

SpecialNameKind:
  as: Enum
  node: false
  derive: Copy
  Self_: Span
  Parent: Span
  Static: Span

UnresolvedName:
  span: Span
  symbol: ByteString
  qualification: NameQualification

ResolvedName:
  span: Span
  resolved: ByteString
  original: ByteString

Property:
  children: [self]
  as: Enum
  Simple: SimpleProperty
  Hooked: HookedProperty

SimpleProperty:
  children: [attributes, r#type?, entries]
  span: Span
  attributes: Vec<AttributeGroup>
  modifiers: PropertyModifierGroup
  var: Option<Span>
  r#type: Option<DataType>
  entries: Vec<PropertyEntry>
  semicolon: Span

HookedProperty:
  children: [attributes, r#type?, entry, hooks]
  span: Span
  attributes: Vec<AttributeGroup>
  modifiers: PropertyModifierGroup
  r#type: Option<DataType>
  entry: PropertyEntry
  hooks: PropertyHookList

PropertyHookList:
  children: [hooks]
  span: Span
  left_brace: Span
  hooks: Vec<PropertyHook>
  right_brace: Span

PropertyHook:
  children: [parameters?, body]
  span: Span
  kind: PropertyHookKind
  parameters: Option<FunctionParameterList>
  body: PropertyHookBody

PropertyHookBody:
  children: [self]
  as: Enum
  Abstract: Span
  Concrete: ConcretePropertyHookBody
  Invalid: Span

ConcretePropertyHookBody:
  children: [self]
  as: Enum
  Block: ConcretePropertyHookBodyBlock
  Expression: ConcretePropertyHookBodyExpression

ConcretePropertyHookBodyBlock:
  children: [body]
  span: Span
  left_brace: Span
  body: Vec<Statement>
  right_brace: Span

ConcretePropertyHookBodyExpression:
  children: [expression]
  span: Span
  arrow: Span
  expression: Expression
  semicolon: Span

PropertyHookKind:
  as: Enum
  node: false
  Get: Span
  Set: Span
  Invalid: Span

PropertyEntry:
  children: [kind]
  span: Span
  kind: PropertyEntryKind

PropertyEntryKind:
  as: Enum
  Uninitialized: UninitializedPropertyEntry
  Initialized: InitializedPropertyEntry

UninitializedPropertyEntry:
  children: [variable]
  span: Span
  variable: SimpleVariable

InitializedPropertyEntry:
  children: [variable, value]
  span: Span
  variable: SimpleVariable
  equals: Span
  value: Expression

TraitBody:
  children: [members]
  span: Span
  left_brace: Span
  members: Vec<ClassishMember>
  right_brace: Span

TraitStatement:
  children: [name, attributes, body]
  span: Span
  r#trait: Span
  name: Name
  attributes: Vec<AttributeGroup>
  body: TraitBody

TraitUsage:
  children: [traits, adaptations]
  span: Span
  r#use: Span
  traits: Vec<Name>
  adaptations: Vec<TraitUsageAdaptation>

TraitUsageAdaptation:
  children: [kind]
  span: Span
  kind: TraitUsageAdaptationKind

TraitUsageAdaptationKind:
  as: Enum
  Alias: TraitUsageAdaptationAlias
  Visibility: TraitUsageAdaptationVisibility
  Precedence: TraitUsageAdaptationPrecedence

TraitUsageAdaptationAlias:
  children: [r#trait?, method, alias]
  span: Span
  r#trait: Option<Name>
  method: SimpleIdentifier
  alias: SimpleIdentifier
  visibility: Option<VisibilityModifier>

TraitUsageAdaptationVisibility:
  children: [r#trait?, method]
  span: Span
  r#trait: Option<Name>
  method: SimpleIdentifier
  visibility: VisibilityModifier

TraitUsageAdaptationPrecedence:
  children: [r#trait?, method, insteadof]
  span: Span
  r#trait: Option<Name>
  method: SimpleIdentifier
  insteadof: Vec<SimpleIdentifier>

CatchType:
  children: [kind]
  span: Span
  kind: CatchTypeKind

CatchTypeKind:
  as: Enum
  Identifier: CatchTypeKindIdentifier
  Union: CatchTypeKindUnion

CatchTypeKindIdentifier:
  children: [identifier]
  span: Span
  identifier: SimpleIdentifier

CatchTypeKindUnion:
  children: [identifiers]
  span: Span
  identifiers: Vec<SimpleIdentifier>

TryStatement:
  children: [body, catches, finally?]
  span: Span
  start: Span
  end: Span
  body: Block
  catches: Vec<CatchBlock>
  finally: Option<FinallyBlock>

CatchBlock:
  children: [types, var?, body]
  span: Span
  start: Span
  end: Span
  types: CatchType
  var: Option<SimpleVariable>
  body: Block

FinallyBlock:
  children: [body]
  span: Span
  start: Span
  end: Span
  body: Block

Variable:
  children: [self]
  as: Enum
  SimpleVariable: SimpleVariable
  VariableVariable: VariableVariable
  BracedVariableVariable: BracedVariableVariable

SimpleVariable:
  symbol: ByteString
  stripped: ByteString
  span: Span

VariableVariable:
  children: [variable]
  span: Span
  variable: Box<Variable>

BracedVariableVariable:
  children: [variable]
  span: Span
  start: Span
  variable: Box<Expression>
  end: Span

Ending:
  as: Enum
  node: false
  Missing: Span
  Semicolon: Span
  CloseTag: Span

StaticStatement:
  children: [vars]
  span: Span
  vars: Vec<StaticVar>
  semicolon: Span

SwitchStatement:
  children: [condition, cases]
  span: Span
  switch: Span
  left_parenthesis: Span
  condition: Expression
  right_parenthesis: Span
  cases: Vec<Case>

EchoStatement:
  children: [values]
  span: Span
  echo: Span
  values: Vec<Expression>
  ending: Ending

ReturnStatement:
  children: [value?]
  span: Span
  r#return: Span
  value: Option<Expression>
  ending: Ending

UseStatement:
  children: [uses]
  span: Span
  kind: UseKind
  uses: Vec<Use>

GroupUseStatement:
  children: [prefix, uses]
  span: Span
  prefix: SimpleIdentifier
  kind: UseKind
  uses: Vec<Use>

HaltCompilerStatement:
  span: Span
  content: Option<OwnedToken>

StaticVar:
  children: [var, default?]
  span: Span
  var: Variable
  default: Option<Expression>

Comment:
  children: [kind]
  span: Span
  kind: CommentKind

CommentKind:
  as: Enum
  children: [self]
  SingleLine: SingleLineComment
  MultiLine: MultiLineComment
  HashMark: HashMarkComment
  DocBlock: DocBlockComment

SingleLineComment:
  span: Span
  content: ByteString

MultiLineComment:
  span: Span
  content: ByteString

HashMarkComment:
  span: Span
  content: ByteString

DocBlockComment:
  children: [doc]
  span: Span
  doc: DocBlock

DocBlock:
  children: [nodes]
  span: Span
  nodes: Vec<DocBlockNode>

DocBlockNode:
  children: [self]
  as: Enum
  Text: DocBlockTextNode
  Tag: DocBlockTagNode

DocBlockTextNode:
  span: Span
  content: ByteString

DocBlockTagNode:
  span: Span
  tag: DocBlockTag

DocBlockTag:
  children: [self]
  as: Enum
  Param: DocBlockParamTag
  Return: DocBlockReturnTag
  Throws: DocBlockThrowsTag
  Var: DocBlockVarTag
  Property: DocBlockPropertyTag
  Method: DocBlockMethodTag
  Template: DocBlockTemplateTag
  Extends: DocBlockExtendsTag
  Implements: DocBlockImplementsTag
  Uses: DocBlockUsesTag
  Deprecated: DocBlockDeprecatedTag
  Generic: DocBlockGenericTag

DocBlockParamTag:
  span: Span
  tag: OwnedToken
  data_type: Option<DataType>
  ampersand: Option<Span>
  ellipsis: Option<Span>
  variable: Option<SimpleVariable>
  text: Option<ByteString>

DocBlockReturnTag:
  span: Span
  tag: OwnedToken
  data_type: Option<DataType>
  text: Option<ByteString>

DocBlockThrowsTag:
  span: Span
  tag: OwnedToken
  data_type: Option<DataType>
  text: Option<ByteString>

DocBlockVarTag:
  span: Span
  tag: OwnedToken
  data_type: Option<DataType>
  variable: Option<SimpleVariable>
  text: Option<ByteString>

DocBlockPropertyTag:
  span: Span
  tag: OwnedToken
  data_type: Option<DataType>
  variable: Option<SimpleVariable>
  text: Option<ByteString>

DocBlockMethodTag:
  span: Span
  tag: OwnedToken
  r#static: Option<Span>
  return_type: Option<DataType>
  name: SimpleIdentifier
  left_parenthesis: Span
  parameters: FunctionParameterList
  right_parenthesis: Span
  text: Option<ByteString>

DocBlockTemplateTag:
  span: Span
  tag: OwnedToken
  placeholder: SimpleIdentifier
  constraint: Option<DataType>
  text: Option<ByteString>

DocBlockExtendsTag:
  span: Span
  tag: OwnedToken
  data_type: Option<DataType>
  text: Option<ByteString>

DocBlockImplementsTag:
  span: Span
  tag: OwnedToken
  data_type: Option<DataType>
  text: Option<ByteString>

DocBlockUsesTag:
  span: Span
  tag: OwnedToken
  data_type: Option<DataType>
  text: Option<ByteString>

DocBlockDeprecatedTag:
  span: Span
  tag: OwnedToken
  text: Option<ByteString>

DocBlockGenericTag:
  span: Span
  tag: OwnedToken
  text: Option<ByteString>

CommentGroup:
  derive: Default
  comments: Vec<Comment>
