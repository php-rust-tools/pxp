// This file is generated by meta/scripts/generate-ast.php.
// Do not make modifications to this file directly.

use crate::utils::CommaSeparated;
use crate::Node;
use pxp_span::Span;
use pxp_symbol::Symbol;
use pxp_syntax::backed_enum_type::BackedEnumType;
use pxp_syntax::comments::{Comment, CommentGroup};
use pxp_syntax::name::NameQualification;
use pxp_token::Token;
use pxp_type::Type;

pub type Block = Vec<Statement>;

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct Statement {
    pub kind: StatementKind,
    pub span: Span,
    pub comments: CommentGroup,
}

impl Node for Statement {
    fn name(&self) -> &'static str {
        "Statement"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.kind]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum StatementKind {
    FullOpeningTag(FullOpeningTagStatement),
    ShortOpeningTag(ShortOpeningTagStatement),
    EchoOpeningTag(EchoOpeningTagStatement),
    ClosingTag(ClosingTagStatement),
    InlineHtml(InlineHtmlStatement),
    Label(LabelStatement),
    Goto(GotoStatement),
    HaltCompiler(HaltCompilerStatement),
    Static(StaticStatement),
    DoWhile(DoWhileStatement),
    While(WhileStatement),
    For(ForStatement),
    Foreach(ForeachStatement),
    Break(BreakStatement),
    Continue(ContinueStatement),
    Constant(ConstantStatement),
    Function(FunctionStatement),
    Class(ClassStatement),
    Trait(TraitStatement),
    Interface(InterfaceStatement),
    If(IfStatement),
    Switch(SwitchStatement),
    Echo(EchoStatement),
    Expression(ExpressionStatement),
    Return(ReturnStatement),
    Namespace(NamespaceStatement),
    Use(UseStatement),
    GroupUse(GroupUseStatement),
    Comment(Comment),
    Try(TryStatement),
    UnitEnum(UnitEnumStatement),
    BackedEnum(BackedEnumStatement),
    Block(BlockStatement),
    Global(GlobalStatement),
    Declare(DeclareStatement),
    Noop(Span),
}

impl Node for StatementKind {
    fn name(&self) -> &'static str {
        "StatementKind"
    }

    fn children(&self) -> Vec<&dyn Node> {
        match self {
            Self::FullOpeningTag(node) => vec![node],
            Self::ShortOpeningTag(node) => vec![node],
            Self::EchoOpeningTag(node) => vec![node],
            Self::ClosingTag(node) => vec![node],
            Self::InlineHtml(node) => vec![node],
            Self::Label(node) => vec![node],
            Self::Goto(node) => vec![node],
            Self::HaltCompiler(node) => vec![node],
            Self::Static(node) => vec![node],
            Self::DoWhile(node) => vec![node],
            Self::While(node) => vec![node],
            Self::For(node) => vec![node],
            Self::Foreach(node) => vec![node],
            Self::Break(node) => vec![node],
            Self::Continue(node) => vec![node],
            Self::Constant(node) => vec![node],
            Self::Function(node) => vec![node],
            Self::Class(node) => vec![node],
            Self::Trait(node) => vec![node],
            Self::Interface(node) => vec![node],
            Self::If(node) => vec![node],
            Self::Switch(node) => vec![node],
            Self::Echo(node) => vec![node],
            Self::Expression(node) => vec![node],
            Self::Return(node) => vec![node],
            Self::Namespace(node) => vec![node],
            Self::Use(node) => vec![node],
            Self::GroupUse(node) => vec![node],
            Self::Try(node) => vec![node],
            Self::UnitEnum(node) => vec![node],
            Self::BackedEnum(node) => vec![node],
            Self::Block(node) => vec![node],
            Self::Global(node) => vec![node],
            Self::Declare(node) => vec![node],
            _ => vec![],
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct Expression {
    pub kind: ExpressionKind,
    pub span: Span,
    pub comments: CommentGroup,
}

impl Node for Expression {
    fn name(&self) -> &'static str {
        "Expression"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.kind]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ExpressionKind {
    Missing,
    Eval(EvalExpression),
    Empty(EmptyExpression),
    Die(DieExpression),
    Exit(ExitExpression),
    Isset(IssetExpression),
    Unset(UnsetExpression),
    Print(PrintExpression),
    Literal(Literal),
    ArithmeticOperation(ArithmeticOperationExpression),
    AssignmentOperation(AssignmentOperationExpression),
    BitwiseOperation(BitwiseOperationExpression),
    ComparisonOperation(ComparisonOperationExpression),
    LogicalOperation(LogicalOperationExpression),
    Concat(ConcatExpression),
    Instanceof(InstanceofExpression),
    Reference(ReferenceExpression),
    Parenthesized(ParenthesizedExpression),
    ErrorSuppress(ErrorSuppressExpression),
    Identifier(Identifier),
    Variable(Variable),
    Include(IncludeExpression),
    IncludeOnce(IncludeOnceExpression),
    Require(RequireExpression),
    RequireOnce(RequireOnceExpression),
    FunctionCall(FunctionCallExpression),
    FunctionClosureCreation(FunctionClosureCreationExpression),
    MethodCall(MethodCallExpression),
    MethodClosureCreation(MethodClosureCreationExpression),
    NullsafeMethodCall(NullsafeMethodCallExpression),
    StaticMethodCall(StaticMethodCallExpression),
    StaticVariableMethodCall(StaticVariableMethodCallExpression),
    StaticMethodClosureCreation(StaticMethodClosureCreationExpression),
    StaticVariableMethodClosureCreation(StaticVariableMethodClosureCreationExpression),
    PropertyFetch(PropertyFetchExpression),
    NullsafePropertyFetch(NullsafePropertyFetchExpression),
    StaticPropertyFetch(StaticPropertyFetchExpression),
    ConstantFetch(ConstantFetchExpression),
    Static,
    Self_,
    Parent,
    ShortArray(ShortArrayExpression),
    Array(ArrayExpression),
    List(ListExpression),
    Closure(ClosureExpression),
    ArrowFunction(ArrowFunctionExpression),
    New(NewExpression),
    InterpolatedString(InterpolatedStringExpression),
    Heredoc(HeredocExpression),
    Nowdoc(NowdocExpression),
    ShellExec(ShellExecExpression),
    AnonymousClass(AnonymousClassExpression),
    Bool(BoolExpression),
    ArrayIndex(ArrayIndexExpression),
    Null,
    MagicConstant(MagicConstantExpression),
    ShortTernary(ShortTernaryExpression),
    Ternary(TernaryExpression),
    Coalesce(CoalesceExpression),
    Clone(CloneExpression),
    Match(MatchExpression),
    Throw(ThrowExpression),
    Yield(YieldExpression),
    YieldFrom(YieldFromExpression),
    Cast(CastExpression),
    Name(Name),
    Noop,
}

impl Node for ExpressionKind {
    fn name(&self) -> &'static str {
        "ExpressionKind"
    }

    fn children(&self) -> Vec<&dyn Node> {
        match self {
            Self::Eval(node) => vec![node],
            Self::Empty(node) => vec![node],
            Self::Die(node) => vec![node],
            Self::Exit(node) => vec![node],
            Self::Isset(node) => vec![node],
            Self::Unset(node) => vec![node],
            Self::Print(node) => vec![node],
            Self::Literal(node) => vec![node],
            Self::ArithmeticOperation(node) => vec![node],
            Self::AssignmentOperation(node) => vec![node],
            Self::BitwiseOperation(node) => vec![node],
            Self::ComparisonOperation(node) => vec![node],
            Self::LogicalOperation(node) => vec![node],
            Self::Concat(node) => vec![node],
            Self::Instanceof(node) => vec![node],
            Self::Reference(node) => vec![node],
            Self::Parenthesized(node) => vec![node],
            Self::ErrorSuppress(node) => vec![node],
            Self::Identifier(node) => vec![node],
            Self::Variable(node) => vec![node],
            Self::Include(node) => vec![node],
            Self::IncludeOnce(node) => vec![node],
            Self::Require(node) => vec![node],
            Self::RequireOnce(node) => vec![node],
            Self::FunctionCall(node) => vec![node],
            Self::FunctionClosureCreation(node) => vec![node],
            Self::MethodCall(node) => vec![node],
            Self::MethodClosureCreation(node) => vec![node],
            Self::NullsafeMethodCall(node) => vec![node],
            Self::StaticMethodCall(node) => vec![node],
            Self::StaticVariableMethodCall(node) => vec![node],
            Self::StaticMethodClosureCreation(node) => vec![node],
            Self::StaticVariableMethodClosureCreation(node) => vec![node],
            Self::PropertyFetch(node) => vec![node],
            Self::NullsafePropertyFetch(node) => vec![node],
            Self::StaticPropertyFetch(node) => vec![node],
            Self::ConstantFetch(node) => vec![node],
            Self::ShortArray(node) => vec![node],
            Self::Array(node) => vec![node],
            Self::List(node) => vec![node],
            Self::Closure(node) => vec![node],
            Self::ArrowFunction(node) => vec![node],
            Self::New(node) => vec![node],
            Self::InterpolatedString(node) => vec![node],
            Self::Heredoc(node) => vec![node],
            Self::Nowdoc(node) => vec![node],
            Self::ShellExec(node) => vec![node],
            Self::AnonymousClass(node) => vec![node],
            Self::Bool(node) => vec![node],
            Self::ArrayIndex(node) => vec![node],
            Self::MagicConstant(node) => vec![node],
            Self::ShortTernary(node) => vec![node],
            Self::Ternary(node) => vec![node],
            Self::Coalesce(node) => vec![node],
            Self::Clone(node) => vec![node],
            Self::Match(node) => vec![node],
            Self::Throw(node) => vec![node],
            Self::Yield(node) => vec![node],
            Self::YieldFrom(node) => vec![node],
            Self::Cast(node) => vec![node],
            Self::Name(node) => vec![node],
            _ => vec![],
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct InlineHtmlStatement {
    pub html: Token,
}

impl Node for InlineHtmlStatement {
    fn name(&self) -> &'static str {
        "InlineHtmlStatement"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct FullOpeningTagStatement {
    pub span: Span,
}

impl Node for FullOpeningTagStatement {
    fn name(&self) -> &'static str {
        "FullOpeningTagStatement"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ShortOpeningTagStatement {
    pub span: Span,
}

impl Node for ShortOpeningTagStatement {
    fn name(&self) -> &'static str {
        "ShortOpeningTagStatement"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct EchoOpeningTagStatement {
    pub span: Span,
}

impl Node for EchoOpeningTagStatement {
    fn name(&self) -> &'static str {
        "EchoOpeningTagStatement"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ClosingTagStatement {
    pub span: Span,
}

impl Node for ClosingTagStatement {
    fn name(&self) -> &'static str {
        "ClosingTagStatement"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ExpressionStatement {
    pub expression: Expression,
    pub ending: Ending,
}

impl Node for ExpressionStatement {
    fn name(&self) -> &'static str {
        "ExpressionStatement"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.expression, &self.ending]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct GlobalStatement {
    pub global: Span,
    pub variables: Vec<Variable>,
}

impl Node for GlobalStatement {
    fn name(&self) -> &'static str {
        "GlobalStatement"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.variables]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct BlockStatement {
    pub left_brace: Span,
    pub statements: Vec<Statement>,
    pub right_brace: Span,
}

impl Node for BlockStatement {
    fn name(&self) -> &'static str {
        "BlockStatement"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.statements]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum CastKind {
    Int,
    Bool,
    Float,
    String,
    Array,
    Object,
    Unset,
}

impl Node for CastKind {
    fn name(&self) -> &'static str {
        "CastKind"
    }

    fn children(&self) -> Vec<&dyn Node> {
        match self {
            _ => vec![],
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct Case {
    pub condition: Option<Expression>,
    pub body: Block,
}

impl Node for Case {
    fn name(&self) -> &'static str {
        "Case"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.condition, &self.body]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct Use {
    pub name: Name,
    pub alias: Option<SimpleIdentifier>,
    pub kind: Option<UseKind>,
}

impl Node for Use {
    fn name(&self) -> &'static str {
        "Use"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.name, &self.alias, &self.kind]
    }
}

#[derive(Debug, PartialEq, Eq, Clone, Hash, Copy)]
pub enum UseKind {
    Normal,
    Function,
    Const,
}

impl Node for UseKind {
    fn name(&self) -> &'static str {
        "UseKind"
    }

    fn children(&self) -> Vec<&dyn Node> {
        match self {
            _ => vec![],
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct EvalExpression {
    pub eval: Span,
    pub argument: Box<SingleArgument>,
}

impl Node for EvalExpression {
    fn name(&self) -> &'static str {
        "EvalExpression"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.argument]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct EmptyExpression {
    pub empty: Span,
    pub argument: Box<SingleArgument>,
}

impl Node for EmptyExpression {
    fn name(&self) -> &'static str {
        "EmptyExpression"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.argument]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct DieExpression {
    pub die: Span,
    pub argument: Option<Box<SingleArgument>>,
}

impl Node for DieExpression {
    fn name(&self) -> &'static str {
        "DieExpression"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.argument]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ExitExpression {
    pub exit: Span,
    pub argument: Option<Box<SingleArgument>>,
}

impl Node for ExitExpression {
    fn name(&self) -> &'static str {
        "ExitExpression"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.argument]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct IssetExpression {
    pub isset: Span,
    pub arguments: ArgumentList,
}

impl Node for IssetExpression {
    fn name(&self) -> &'static str {
        "IssetExpression"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.arguments]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct UnsetExpression {
    pub unset: Span,
    pub arguments: ArgumentList,
}

impl Node for UnsetExpression {
    fn name(&self) -> &'static str {
        "UnsetExpression"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.arguments]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct PrintExpression {
    pub print: Span,
    pub value: Option<Box<Expression>>,
    pub argument: Option<Box<SingleArgument>>,
}

impl Node for PrintExpression {
    fn name(&self) -> &'static str {
        "PrintExpression"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.value, &self.argument]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ConcatExpression {
    pub left: Box<Expression>,
    pub dot: Span,
    pub right: Box<Expression>,
}

impl Node for ConcatExpression {
    fn name(&self) -> &'static str {
        "ConcatExpression"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.left, &self.right]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct InstanceofExpression {
    pub left: Box<Expression>,
    pub instanceof: Span,
    pub right: Box<Expression>,
}

impl Node for InstanceofExpression {
    fn name(&self) -> &'static str {
        "InstanceofExpression"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.left, &self.right]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ReferenceExpression {
    pub ampersand: Span,
    pub right: Box<Expression>,
}

impl Node for ReferenceExpression {
    fn name(&self) -> &'static str {
        "ReferenceExpression"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.right]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ParenthesizedExpression {
    pub start: Span,
    pub expr: Box<Expression>,
    pub end: Span,
}

impl Node for ParenthesizedExpression {
    fn name(&self) -> &'static str {
        "ParenthesizedExpression"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.expr]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ErrorSuppressExpression {
    pub at: Span,
    pub expr: Box<Expression>,
}

impl Node for ErrorSuppressExpression {
    fn name(&self) -> &'static str {
        "ErrorSuppressExpression"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.expr]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct IncludeExpression {
    pub include: Span,
    pub path: Box<Expression>,
}

impl Node for IncludeExpression {
    fn name(&self) -> &'static str {
        "IncludeExpression"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.path]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct IncludeOnceExpression {
    pub include_once: Span,
    pub path: Box<Expression>,
}

impl Node for IncludeOnceExpression {
    fn name(&self) -> &'static str {
        "IncludeOnceExpression"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.path]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct RequireExpression {
    pub require: Span,
    pub path: Box<Expression>,
}

impl Node for RequireExpression {
    fn name(&self) -> &'static str {
        "RequireExpression"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.path]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct RequireOnceExpression {
    pub require_once: Span,
    pub path: Box<Expression>,
}

impl Node for RequireOnceExpression {
    fn name(&self) -> &'static str {
        "RequireOnceExpression"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.path]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct FunctionCallExpression {
    pub target: Box<Expression>,
    pub arguments: ArgumentList,
}

impl Node for FunctionCallExpression {
    fn name(&self) -> &'static str {
        "FunctionCallExpression"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.target, &self.arguments]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct FunctionClosureCreationExpression {
    pub target: Box<Expression>,
    pub placeholder: ArgumentPlaceholder,
}

impl Node for FunctionClosureCreationExpression {
    fn name(&self) -> &'static str {
        "FunctionClosureCreationExpression"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.target, &self.placeholder]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct MethodCallExpression {
    pub target: Box<Expression>,
    pub arrow: Span,
    pub method: Box<Expression>,
    pub arguments: ArgumentList,
}

impl Node for MethodCallExpression {
    fn name(&self) -> &'static str {
        "MethodCallExpression"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.target, &self.method, &self.arguments]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct MethodClosureCreationExpression {
    pub target: Box<Expression>,
    pub arrow: Span,
    pub method: Box<Expression>,
    pub placeholder: ArgumentPlaceholder,
}

impl Node for MethodClosureCreationExpression {
    fn name(&self) -> &'static str {
        "MethodClosureCreationExpression"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.target, &self.method, &self.placeholder]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct NullsafeMethodCallExpression {
    pub target: Box<Expression>,
    pub question_arrow: Span,
    pub method: Box<Expression>,
    pub arguments: ArgumentList,
}

impl Node for NullsafeMethodCallExpression {
    fn name(&self) -> &'static str {
        "NullsafeMethodCallExpression"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.target, &self.method, &self.arguments]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct StaticMethodCallExpression {
    pub target: Box<Expression>,
    pub double_colon: Span,
    pub method: Identifier,
    pub arguments: ArgumentList,
}

impl Node for StaticMethodCallExpression {
    fn name(&self) -> &'static str {
        "StaticMethodCallExpression"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.target, &self.method, &self.arguments]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct StaticVariableMethodCallExpression {
    pub target: Box<Expression>,
    pub double_colon: Span,
    pub method: Variable,
    pub arguments: ArgumentList,
}

impl Node for StaticVariableMethodCallExpression {
    fn name(&self) -> &'static str {
        "StaticVariableMethodCallExpression"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.target, &self.method, &self.arguments]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct StaticMethodClosureCreationExpression {
    pub target: Box<Expression>,
    pub double_colon: Span,
    pub method: Identifier,
    pub placeholder: ArgumentPlaceholder,
}

impl Node for StaticMethodClosureCreationExpression {
    fn name(&self) -> &'static str {
        "StaticMethodClosureCreationExpression"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.target, &self.method, &self.placeholder]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct StaticVariableMethodClosureCreationExpression {
    pub target: Box<Expression>,
    pub double_colon: Span,
    pub method: Variable,
    pub placeholder: ArgumentPlaceholder,
}

impl Node for StaticVariableMethodClosureCreationExpression {
    fn name(&self) -> &'static str {
        "StaticVariableMethodClosureCreationExpression"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.target, &self.method, &self.placeholder]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct PropertyFetchExpression {
    pub target: Box<Expression>,
    pub arrow: Span,
    pub property: Box<Expression>,
}

impl Node for PropertyFetchExpression {
    fn name(&self) -> &'static str {
        "PropertyFetchExpression"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.target, &self.property]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct NullsafePropertyFetchExpression {
    pub target: Box<Expression>,
    pub question_arrow: Span,
    pub property: Box<Expression>,
}

impl Node for NullsafePropertyFetchExpression {
    fn name(&self) -> &'static str {
        "NullsafePropertyFetchExpression"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.target, &self.property]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct StaticPropertyFetchExpression {
    pub target: Box<Expression>,
    pub double_colon: Span,
    pub property: Variable,
}

impl Node for StaticPropertyFetchExpression {
    fn name(&self) -> &'static str {
        "StaticPropertyFetchExpression"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.target, &self.property]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ConstantFetchExpression {
    pub target: Box<Expression>,
    pub double_colon: Span,
    pub constant: Identifier,
}

impl Node for ConstantFetchExpression {
    fn name(&self) -> &'static str {
        "ConstantFetchExpression"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.target, &self.constant]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ShortArrayExpression {
    pub start: Span,
    pub items: CommaSeparated<ArrayItem>,
    pub end: Span,
}

impl Node for ShortArrayExpression {
    fn name(&self) -> &'static str {
        "ShortArrayExpression"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.items]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ArrayExpression {
    pub array: Span,
    pub start: Span,
    pub items: CommaSeparated<ArrayItem>,
    pub end: Span,
}

impl Node for ArrayExpression {
    fn name(&self) -> &'static str {
        "ArrayExpression"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.items]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ListExpression {
    pub list: Span,
    pub start: Span,
    pub items: Vec<ListEntry>,
    pub end: Span,
}

impl Node for ListExpression {
    fn name(&self) -> &'static str {
        "ListExpression"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.items]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct NewExpression {
    pub new: Span,
    pub target: Box<Expression>,
    pub arguments: Option<ArgumentList>,
}

impl Node for NewExpression {
    fn name(&self) -> &'static str {
        "NewExpression"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.target, &self.arguments]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct InterpolatedStringExpression {
    pub parts: Vec<StringPart>,
}

impl Node for InterpolatedStringExpression {
    fn name(&self) -> &'static str {
        "InterpolatedStringExpression"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.parts]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct HeredocExpression {
    pub label: Symbol,
    pub parts: Vec<StringPart>,
}

impl Node for HeredocExpression {
    fn name(&self) -> &'static str {
        "HeredocExpression"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.parts]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct NowdocExpression {
    pub label: Token,
    pub value: Token,
}

impl Node for NowdocExpression {
    fn name(&self) -> &'static str {
        "NowdocExpression"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ShellExecExpression {
    pub parts: Vec<StringPart>,
}

impl Node for ShellExecExpression {
    fn name(&self) -> &'static str {
        "ShellExecExpression"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.parts]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct BoolExpression {
    pub value: bool,
}

impl Node for BoolExpression {
    fn name(&self) -> &'static str {
        "BoolExpression"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ArrayIndexExpression {
    pub array: Box<Expression>,
    pub left_bracket: Span,
    pub index: Option<Box<Expression>>,
    pub right_bracket: Span,
}

impl Node for ArrayIndexExpression {
    fn name(&self) -> &'static str {
        "ArrayIndexExpression"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.array, &self.index]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ShortTernaryExpression {
    pub condition: Box<Expression>,
    pub question_colon: Span,
    pub r#else: Box<Expression>,
}

impl Node for ShortTernaryExpression {
    fn name(&self) -> &'static str {
        "ShortTernaryExpression"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.condition, &self.r#else]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct TernaryExpression {
    pub condition: Box<Expression>,
    pub question: Span,
    pub then: Box<Expression>,
    pub colon: Span,
    pub r#else: Box<Expression>,
}

impl Node for TernaryExpression {
    fn name(&self) -> &'static str {
        "TernaryExpression"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.condition, &self.then, &self.r#else]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct CoalesceExpression {
    pub lhs: Box<Expression>,
    pub double_question: Span,
    pub rhs: Box<Expression>,
}

impl Node for CoalesceExpression {
    fn name(&self) -> &'static str {
        "CoalesceExpression"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.lhs, &self.rhs]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct CloneExpression {
    pub target: Box<Expression>,
}

impl Node for CloneExpression {
    fn name(&self) -> &'static str {
        "CloneExpression"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.target]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct MatchExpression {
    pub keyword: Span,
    pub left_parenthesis: Span,
    pub condition: Box<Expression>,
    pub right_parenthesis: Span,
    pub left_brace: Span,
    pub default: Option<Box<DefaultMatchArm>>,
    pub arms: Vec<MatchArm>,
    pub right_brace: Span,
}

impl Node for MatchExpression {
    fn name(&self) -> &'static str {
        "MatchExpression"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.condition, &self.default, &self.arms]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ThrowExpression {
    pub value: Box<Expression>,
}

impl Node for ThrowExpression {
    fn name(&self) -> &'static str {
        "ThrowExpression"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.value]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct YieldExpression {
    pub key: Option<Box<Expression>>,
    pub value: Option<Box<Expression>>,
}

impl Node for YieldExpression {
    fn name(&self) -> &'static str {
        "YieldExpression"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.key, &self.value]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct YieldFromExpression {
    pub value: Box<Expression>,
}

impl Node for YieldFromExpression {
    fn name(&self) -> &'static str {
        "YieldFromExpression"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.value]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct CastExpression {
    pub cast: Span,
    pub kind: CastKind,
    pub value: Box<Expression>,
}

impl Node for CastExpression {
    fn name(&self) -> &'static str {
        "CastExpression"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.kind, &self.value]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct DefaultMatchArm {
    pub keyword: Span,
    pub double_arrow: Span,
    pub body: Expression,
}

impl Node for DefaultMatchArm {
    fn name(&self) -> &'static str {
        "DefaultMatchArm"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.body]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct MatchArm {
    pub conditions: Vec<Expression>,
    pub arrow: Span,
    pub body: Expression,
}

impl Node for MatchArm {
    fn name(&self) -> &'static str {
        "MatchArm"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.conditions, &self.body]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum MagicConstantExpression {
    Directory(Span),
    File(Span),
    Line(Span),
    Function(Span),
    Class(Span),
    Method(Span),
    Namespace(Span),
    Trait(Span),
    CompilerHaltOffset(Span),
}

impl Node for MagicConstantExpression {
    fn name(&self) -> &'static str {
        "MagicConstantExpression"
    }

    fn children(&self) -> Vec<&dyn Node> {
        match self {
            _ => vec![],
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum StringPart {
    Literal(LiteralStringPart),
    Expression(ExpressionStringPart),
}

impl Node for StringPart {
    fn name(&self) -> &'static str {
        "StringPart"
    }

    fn children(&self) -> Vec<&dyn Node> {
        match self {
            Self::Literal(node) => vec![node],
            Self::Expression(node) => vec![node],
            _ => vec![],
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct LiteralStringPart {
    pub value: Symbol,
}

impl Node for LiteralStringPart {
    fn name(&self) -> &'static str {
        "LiteralStringPart"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ExpressionStringPart {
    pub expression: Box<Expression>,
}

impl Node for ExpressionStringPart {
    fn name(&self) -> &'static str {
        "ExpressionStringPart"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.expression]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ArrayItem {
    Skipped,
    Value {
        value: Expression,
    },
    ReferencedValue {
        ampersand: Span,
        value: Expression,
    },
    SpreadValue {
        ellipsis: Span,
        value: Expression,
    },
    KeyValue {
        key: Expression,
        double_arrow: Span,
        value: Expression,
    },
    ReferencedKeyValue {
        key: Expression,
        double_arrow: Span,
        ampersand: Span,
        value: Expression,
    },
}

impl Node for ArrayItem {
    fn name(&self) -> &'static str {
        "ArrayItem"
    }

    fn children(&self) -> Vec<&dyn Node> {
        match self {
            Self::Value { value } => {
                vec![value]
            }
            Self::ReferencedValue { ampersand, value } => {
                vec![value]
            }
            Self::SpreadValue { ellipsis, value } => {
                vec![value]
            }
            Self::KeyValue {
                key,
                double_arrow,
                value,
            } => {
                vec![key, value]
            }
            Self::ReferencedKeyValue {
                key,
                double_arrow,
                ampersand,
                value,
            } => {
                vec![key, value]
            }
            _ => vec![],
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ListEntry {
    Skipped,
    Value {
        value: Expression,
    },
    KeyValue {
        key: Expression,
        double_arrow: Span,
        value: Expression,
    },
}

impl Node for ListEntry {
    fn name(&self) -> &'static str {
        "ListEntry"
    }

    fn children(&self) -> Vec<&dyn Node> {
        match self {
            Self::Value { value } => {
                vec![value]
            }
            Self::KeyValue {
                key,
                double_arrow,
                value,
            } => {
                vec![key, value]
            }
            _ => vec![],
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct PositionalArgument {
    pub comments: CommentGroup,
    pub ellipsis: Option<Span>,
    pub value: Expression,
}

impl Node for PositionalArgument {
    fn name(&self) -> &'static str {
        "PositionalArgument"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.value]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct NamedArgument {
    pub comments: CommentGroup,
    pub name: SimpleIdentifier,
    pub colon: Span,
    pub ellipsis: Option<Span>,
    pub value: Expression,
}

impl Node for NamedArgument {
    fn name(&self) -> &'static str {
        "NamedArgument"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.name, &self.value]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum Argument {
    Positional(PositionalArgument),
    Named(NamedArgument),
}

impl Node for Argument {
    fn name(&self) -> &'static str {
        "Argument"
    }

    fn children(&self) -> Vec<&dyn Node> {
        match self {
            Self::Positional(node) => vec![node],
            Self::Named(node) => vec![node],
            _ => vec![],
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ArgumentList {
    pub comments: CommentGroup,
    pub left_parenthesis: Span,
    pub arguments: Vec<Argument>,
    pub right_parenthesis: Span,
}

impl Node for ArgumentList {
    fn name(&self) -> &'static str {
        "ArgumentList"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.arguments]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct SingleArgument {
    pub comments: CommentGroup,
    pub left_parenthesis: Span,
    pub argument: Option<Argument>,
    pub right_parenthesis: Span,
}

impl Node for SingleArgument {
    fn name(&self) -> &'static str {
        "SingleArgument"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.argument]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ArgumentPlaceholder {
    pub comments: CommentGroup,
    pub left_parenthesis: Span,
    pub ellipsis: Span,
    pub right_parenthesis: Span,
}

impl Node for ArgumentPlaceholder {
    fn name(&self) -> &'static str {
        "ArgumentPlaceholder"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct Attribute {
    pub span: Span,
    pub name: Name,
    pub arguments: Option<ArgumentList>,
}

impl Node for Attribute {
    fn name(&self) -> &'static str {
        "Attribute"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.name, &self.arguments]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct AttributeGroup {
    pub span: Span,
    pub members: Vec<Attribute>,
}

impl Node for AttributeGroup {
    fn name(&self) -> &'static str {
        "AttributeGroup"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.members]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ClassBody {
    pub left_brace: Span,
    pub members: Vec<ClassishMember>,
    pub right_brace: Span,
}

impl Node for ClassBody {
    fn name(&self) -> &'static str {
        "ClassBody"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.members]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ClassStatement {
    pub attributes: Vec<AttributeGroup>,
    pub modifiers: ClassModifierGroup,
    pub class: Span,
    pub name: Name,
    pub extends: Option<ClassExtends>,
    pub implements: Option<ClassImplements>,
    pub body: ClassBody,
}

impl Node for ClassStatement {
    fn name(&self) -> &'static str {
        "ClassStatement"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![
            &self.attributes,
            &self.modifiers,
            &self.name,
            &self.extends,
            &self.implements,
            &self.body,
        ]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct AnonymousClassBody {
    pub left_brace: Span,
    pub members: Vec<ClassishMember>,
    pub right_brace: Span,
}

impl Node for AnonymousClassBody {
    fn name(&self) -> &'static str {
        "AnonymousClassBody"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.members]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct AnonymousClassExpression {
    pub attributes: Vec<AttributeGroup>,
    pub class: Span,
    pub extends: Option<ClassExtends>,
    pub implements: Option<ClassImplements>,
    pub body: AnonymousClassBody,
}

impl Node for AnonymousClassExpression {
    fn name(&self) -> &'static str {
        "AnonymousClassExpression"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![
            &self.attributes,
            &self.extends,
            &self.implements,
            &self.body,
        ]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ClassExtends {
    pub extends: Span,
    pub parent: Name,
}

impl Node for ClassExtends {
    fn name(&self) -> &'static str {
        "ClassExtends"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.parent]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ClassImplements {
    pub implements: Span,
    pub interfaces: CommaSeparated<Name>,
}

impl Node for ClassImplements {
    fn name(&self) -> &'static str {
        "ClassImplements"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.interfaces]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ClassishMember {
    Constant(ClassishConstant),
    TraitUsage(TraitUsage),
    Property(Property),
    VariableProperty(VariableProperty),
    AbstractMethod(AbstractMethod),
    AbstractConstructor(AbstractConstructor),
    ConcreteMethod(ConcreteMethod),
    ConcreteConstructor(ConcreteConstructor),
}

impl Node for ClassishMember {
    fn name(&self) -> &'static str {
        "ClassishMember"
    }

    fn children(&self) -> Vec<&dyn Node> {
        match self {
            Self::Constant(node) => vec![node],
            Self::TraitUsage(node) => vec![node],
            Self::Property(node) => vec![node],
            Self::VariableProperty(node) => vec![node],
            Self::AbstractMethod(node) => vec![node],
            Self::AbstractConstructor(node) => vec![node],
            Self::ConcreteMethod(node) => vec![node],
            Self::ConcreteConstructor(node) => vec![node],
            _ => vec![],
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ConstantEntry {
    pub name: Name,
    pub equals: Span,
    pub value: Expression,
}

impl Node for ConstantEntry {
    fn name(&self) -> &'static str {
        "ConstantEntry"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.name, &self.value]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ClassishConstantEntry {
    pub name: SimpleIdentifier,
    pub equals: Span,
    pub value: Expression,
}

impl Node for ClassishConstantEntry {
    fn name(&self) -> &'static str {
        "ClassishConstantEntry"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.name, &self.value]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ConstantStatement {
    pub comments: CommentGroup,
    pub r#const: Span,
    pub entries: Vec<ConstantEntry>,
    pub semicolon: Span,
}

impl Node for ConstantStatement {
    fn name(&self) -> &'static str {
        "ConstantStatement"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.entries]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ClassishConstant {
    pub comments: CommentGroup,
    pub attributes: Vec<AttributeGroup>,
    pub modifiers: ConstantModifierGroup,
    pub r#const: Span,
    pub data_type: Option<DataType>,
    pub entries: Vec<ClassishConstantEntry>,
    pub semicolon: Span,
}

impl Node for ClassishConstant {
    fn name(&self) -> &'static str {
        "ClassishConstant"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![
            &self.attributes,
            &self.modifiers,
            &self.data_type,
            &self.entries,
        ]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct IfStatement {
    pub r#if: Span,
    pub left_parenthesis: Span,
    pub condition: Expression,
    pub right_parenthesis: Span,
    pub body: IfStatementBody,
}

impl Node for IfStatement {
    fn name(&self) -> &'static str {
        "IfStatement"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.condition, &self.body]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum IfStatementBody {
    Statement {
        statement: Box<Statement>,
        elseifs: Vec<IfStatementElseIf>,
        r#else: Option<IfStatementElse>,
    },
    Block {
        colon: Span,
        statements: Vec<Statement>,
        elseifs: Vec<IfStatementElseIfBlock>,
        r#else: Option<IfStatementElseBlock>,
        endif: Span,
        ending: Ending,
    },
}

impl Node for IfStatementBody {
    fn name(&self) -> &'static str {
        "IfStatementBody"
    }

    fn children(&self) -> Vec<&dyn Node> {
        match self {
            Self::Statement {
                statement,
                elseifs,
                r#else,
            } => {
                vec![statement, elseifs, r#else]
            }
            Self::Block {
                colon,
                statements,
                elseifs,
                r#else,
                endif,
                ending,
            } => {
                vec![statements, elseifs, r#else, ending]
            }
            _ => vec![],
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct IfStatementElseIf {
    pub elseif: Span,
    pub left_parenthesis: Span,
    pub condition: Expression,
    pub right_parenthesis: Span,
    pub statement: Box<Statement>,
}

impl Node for IfStatementElseIf {
    fn name(&self) -> &'static str {
        "IfStatementElseIf"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.condition, &self.statement]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct IfStatementElse {
    pub r#else: Span,
    pub statement: Box<Statement>,
}

impl Node for IfStatementElse {
    fn name(&self) -> &'static str {
        "IfStatementElse"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.statement]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct IfStatementElseIfBlock {
    pub elseif: Span,
    pub left_parenthesis: Span,
    pub condition: Expression,
    pub right_parenthesis: Span,
    pub colon: Span,
    pub statements: Vec<Statement>,
}

impl Node for IfStatementElseIfBlock {
    fn name(&self) -> &'static str {
        "IfStatementElseIfBlock"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.condition, &self.statements]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct IfStatementElseBlock {
    pub r#else: Span,
    pub colon: Span,
    pub statements: Vec<Statement>,
}

impl Node for IfStatementElseBlock {
    fn name(&self) -> &'static str {
        "IfStatementElseBlock"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.statements]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct DataType {
    pub kind: Type<Name>,
    pub span: Span,
}

impl Node for DataType {
    fn name(&self) -> &'static str {
        "DataType"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct DeclareEntry {
    pub key: SimpleIdentifier,
    pub equals: Span,
    pub value: Literal,
}

impl Node for DeclareEntry {
    fn name(&self) -> &'static str {
        "DeclareEntry"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.key, &self.value]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct DeclareEntryGroup {
    pub left_parenthesis: Span,
    pub right_parenthesis: Span,
    pub entries: Vec<DeclareEntry>,
}

impl Node for DeclareEntryGroup {
    fn name(&self) -> &'static str {
        "DeclareEntryGroup"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.entries]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum DeclareBody {
    Noop {
        semicolon: Span,
    },
    Braced {
        left_brace: Span,
        statements: Vec<Statement>,
        right_brace: Span,
    },
    Expression {
        expression: Expression,
        semicolon: Span,
    },
    Block {
        colon: Span,
        statements: Vec<Statement>,
        end: (Span, Span),
    },
}

impl Node for DeclareBody {
    fn name(&self) -> &'static str {
        "DeclareBody"
    }

    fn children(&self) -> Vec<&dyn Node> {
        match self {
            Self::Noop { semicolon } => {
                vec![]
            }
            Self::Braced {
                left_brace,
                statements,
                right_brace,
            } => {
                vec![statements]
            }
            Self::Expression {
                expression,
                semicolon,
            } => {
                vec![expression]
            }
            Self::Block {
                colon,
                statements,
                end,
            } => {
                vec![statements]
            }
            _ => vec![],
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct DeclareStatement {
    pub declare: Span,
    pub entries: DeclareEntryGroup,
    pub body: DeclareBody,
}

impl Node for DeclareStatement {
    fn name(&self) -> &'static str {
        "DeclareStatement"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.entries, &self.body]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct UnitEnumCase {
    pub attributes: Vec<AttributeGroup>,
    pub start: Span,
    pub name: SimpleIdentifier,
    pub end: Span,
}

impl Node for UnitEnumCase {
    fn name(&self) -> &'static str {
        "UnitEnumCase"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.attributes, &self.name]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum UnitEnumMember {
    Case(UnitEnumCase),
    Classish(ClassishMember),
}

impl Node for UnitEnumMember {
    fn name(&self) -> &'static str {
        "UnitEnumMember"
    }

    fn children(&self) -> Vec<&dyn Node> {
        match self {
            Self::Case(node) => vec![node],
            Self::Classish(node) => vec![node],
            _ => vec![],
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct UnitEnumBody {
    pub left_brace: Span,
    pub members: Vec<UnitEnumMember>,
    pub right_brace: Span,
}

impl Node for UnitEnumBody {
    fn name(&self) -> &'static str {
        "UnitEnumBody"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.members]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct UnitEnumStatement {
    pub attributes: Vec<AttributeGroup>,
    pub r#enum: Span,
    pub name: Name,
    pub implements: Vec<Name>,
    pub body: UnitEnumBody,
}

impl Node for UnitEnumStatement {
    fn name(&self) -> &'static str {
        "UnitEnumStatement"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.attributes, &self.name, &self.implements, &self.body]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct BackedEnumCase {
    pub attributes: Vec<AttributeGroup>,
    pub case: Span,
    pub name: SimpleIdentifier,
    pub equals: Span,
    pub value: Expression,
    pub semicolon: Span,
}

impl Node for BackedEnumCase {
    fn name(&self) -> &'static str {
        "BackedEnumCase"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.attributes, &self.name, &self.value]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum BackedEnumMember {
    Case(BackedEnumCase),
    Classish(ClassishMember),
}

impl Node for BackedEnumMember {
    fn name(&self) -> &'static str {
        "BackedEnumMember"
    }

    fn children(&self) -> Vec<&dyn Node> {
        match self {
            Self::Case(node) => vec![node],
            Self::Classish(node) => vec![node],
            _ => vec![],
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct BackedEnumBody {
    pub left_brace: Span,
    pub members: Vec<BackedEnumMember>,
    pub right_brace: Span,
}

impl Node for BackedEnumBody {
    fn name(&self) -> &'static str {
        "BackedEnumBody"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.members]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct BackedEnumStatement {
    pub attributes: Vec<AttributeGroup>,
    pub r#enum: Span,
    pub name: Name,
    pub backed_type: BackedEnumType,
    pub implements: Vec<Name>,
    pub body: BackedEnumBody,
}

impl Node for BackedEnumStatement {
    fn name(&self) -> &'static str {
        "BackedEnumStatement"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.attributes, &self.name, &self.implements, &self.body]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ReturnType {
    pub colon: Span,
    pub data_type: DataType,
}

impl Node for ReturnType {
    fn name(&self) -> &'static str {
        "ReturnType"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.data_type]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct FunctionParameter {
    pub comments: CommentGroup,
    pub name: SimpleVariable,
    pub attributes: Vec<AttributeGroup>,
    pub data_type: Option<DataType>,
    pub ellipsis: Option<Span>,
    pub default: Option<Expression>,
    pub ampersand: Option<Span>,
}

impl Node for FunctionParameter {
    fn name(&self) -> &'static str {
        "FunctionParameter"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.name, &self.attributes, &self.data_type, &self.default]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct FunctionParameterList {
    pub comments: CommentGroup,
    pub left_parenthesis: Span,
    pub parameters: CommaSeparated<FunctionParameter>,
    pub right_parenthesis: Span,
}

impl Node for FunctionParameterList {
    fn name(&self) -> &'static str {
        "FunctionParameterList"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.parameters]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct FunctionBody {
    pub comments: CommentGroup,
    pub left_brace: Span,
    pub statements: Vec<Statement>,
    pub right_brace: Span,
}

impl Node for FunctionBody {
    fn name(&self) -> &'static str {
        "FunctionBody"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.statements]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct FunctionStatement {
    pub comments: CommentGroup,
    pub attributes: Vec<AttributeGroup>,
    pub function: Span,
    pub ampersand: Option<Span>,
    pub name: Name,
    pub parameters: FunctionParameterList,
    pub return_type: Option<ReturnType>,
    pub body: FunctionBody,
}

impl Node for FunctionStatement {
    fn name(&self) -> &'static str {
        "FunctionStatement"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![
            &self.attributes,
            &self.name,
            &self.parameters,
            &self.return_type,
            &self.body,
        ]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ClosureUseVariable {
    pub comments: CommentGroup,
    pub ampersand: Option<Span>,
    pub variable: SimpleVariable,
}

impl Node for ClosureUseVariable {
    fn name(&self) -> &'static str {
        "ClosureUseVariable"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.variable]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ClosureUse {
    pub comments: CommentGroup,
    pub r#use: Span,
    pub left_parenthesis: Span,
    pub variables: CommaSeparated<ClosureUseVariable>,
    pub right_parenthesis: Span,
}

impl Node for ClosureUse {
    fn name(&self) -> &'static str {
        "ClosureUse"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.variables]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ClosureExpression {
    pub comments: CommentGroup,
    pub attributes: Vec<AttributeGroup>,
    pub r#static: Option<Span>,
    pub function: Span,
    pub ampersand: Option<Span>,
    pub parameters: FunctionParameterList,
    pub uses: Option<ClosureUse>,
    pub return_type: Option<ReturnType>,
    pub body: FunctionBody,
}

impl Node for ClosureExpression {
    fn name(&self) -> &'static str {
        "ClosureExpression"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![
            &self.attributes,
            &self.parameters,
            &self.uses,
            &self.return_type,
            &self.body,
        ]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ArrowFunctionExpression {
    pub comments: CommentGroup,
    pub r#static: Option<Span>,
    pub ampersand: Option<Span>,
    pub r#fn: Span,
    pub attributes: Vec<AttributeGroup>,
    pub parameters: FunctionParameterList,
    pub return_type: Option<ReturnType>,
    pub double_arrow: Span,
    pub body: Box<Expression>,
}

impl Node for ArrowFunctionExpression {
    fn name(&self) -> &'static str {
        "ArrowFunctionExpression"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![
            &self.attributes,
            &self.parameters,
            &self.return_type,
            &self.body,
        ]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ConstructorParameter {
    pub attributes: Vec<AttributeGroup>,
    pub comments: CommentGroup,
    pub ampersand: Option<Span>,
    pub name: SimpleVariable,
    pub data_type: Option<DataType>,
    pub ellipsis: Option<Span>,
    pub default: Option<Expression>,
    pub modifiers: PromotedPropertyModifierGroup,
}

impl Node for ConstructorParameter {
    fn name(&self) -> &'static str {
        "ConstructorParameter"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![
            &self.attributes,
            &self.name,
            &self.data_type,
            &self.default,
            &self.modifiers,
        ]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ConstructorParameterList {
    pub comments: CommentGroup,
    pub left_parenthesis: Span,
    pub parameters: CommaSeparated<ConstructorParameter>,
    pub right_parenthesis: Span,
}

impl Node for ConstructorParameterList {
    fn name(&self) -> &'static str {
        "ConstructorParameterList"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.parameters]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct AbstractConstructor {
    pub comments: CommentGroup,
    pub attributes: Vec<AttributeGroup>,
    pub modifiers: MethodModifierGroup,
    pub function: Span,
    pub ampersand: Option<Span>,
    pub name: SimpleIdentifier,
    pub parameters: ConstructorParameterList,
    pub semicolon: Span,
}

impl Node for AbstractConstructor {
    fn name(&self) -> &'static str {
        "AbstractConstructor"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![
            &self.attributes,
            &self.modifiers,
            &self.name,
            &self.parameters,
        ]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ConcreteConstructor {
    pub comments: CommentGroup,
    pub attributes: Vec<AttributeGroup>,
    pub modifiers: MethodModifierGroup,
    pub function: Span,
    pub ampersand: Option<Span>,
    pub name: SimpleIdentifier,
    pub parameters: ConstructorParameterList,
    pub body: MethodBody,
}

impl Node for ConcreteConstructor {
    fn name(&self) -> &'static str {
        "ConcreteConstructor"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![
            &self.attributes,
            &self.modifiers,
            &self.name,
            &self.parameters,
            &self.body,
        ]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct AbstractMethod {
    pub comments: CommentGroup,
    pub attributes: Vec<AttributeGroup>,
    pub modifiers: MethodModifierGroup,
    pub function: Span,
    pub ampersand: Option<Span>,
    pub name: SimpleIdentifier,
    pub parameters: FunctionParameterList,
    pub return_type: Option<ReturnType>,
    pub semicolon: Span,
}

impl Node for AbstractMethod {
    fn name(&self) -> &'static str {
        "AbstractMethod"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![
            &self.attributes,
            &self.modifiers,
            &self.name,
            &self.parameters,
            &self.return_type,
        ]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ConcreteMethod {
    pub comments: CommentGroup,
    pub attributes: Vec<AttributeGroup>,
    pub modifiers: MethodModifierGroup,
    pub function: Span,
    pub ampersand: Option<Span>,
    pub name: SimpleIdentifier,
    pub parameters: FunctionParameterList,
    pub return_type: Option<ReturnType>,
    pub body: MethodBody,
}

impl Node for ConcreteMethod {
    fn name(&self) -> &'static str {
        "ConcreteMethod"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![
            &self.attributes,
            &self.modifiers,
            &self.name,
            &self.parameters,
            &self.return_type,
            &self.body,
        ]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct MethodBody {
    pub comments: CommentGroup,
    pub left_brace: Span,
    pub statements: Vec<Statement>,
    pub right_brace: Span,
}

impl Node for MethodBody {
    fn name(&self) -> &'static str {
        "MethodBody"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.statements]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct LabelStatement {
    pub comments: CommentGroup,
    pub label: SimpleIdentifier,
    pub colon: Span,
}

impl Node for LabelStatement {
    fn name(&self) -> &'static str {
        "LabelStatement"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.label]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct GotoStatement {
    pub comments: CommentGroup,
    pub keyword: Span,
    pub label: SimpleIdentifier,
    pub semicolon: Span,
}

impl Node for GotoStatement {
    fn name(&self) -> &'static str {
        "GotoStatement"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.label]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum Identifier {
    SimpleIdentifier(SimpleIdentifier),
    DynamicIdentifier(DynamicIdentifier),
}

impl Node for Identifier {
    fn name(&self) -> &'static str {
        "Identifier"
    }

    fn children(&self) -> Vec<&dyn Node> {
        match self {
            Self::SimpleIdentifier(node) => vec![node],
            Self::DynamicIdentifier(node) => vec![node],
            _ => vec![],
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct SimpleIdentifier {
    pub symbol: Symbol,
    pub span: Span,
}

impl Node for SimpleIdentifier {
    fn name(&self) -> &'static str {
        "SimpleIdentifier"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct DynamicIdentifier {
    pub span: Span,
    pub expr: Box<Expression>,
}

impl Node for DynamicIdentifier {
    fn name(&self) -> &'static str {
        "DynamicIdentifier"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.expr]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct InterfaceExtends {
    pub extends: Span,
    pub parents: CommaSeparated<Name>,
}

impl Node for InterfaceExtends {
    fn name(&self) -> &'static str {
        "InterfaceExtends"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.parents]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct InterfaceBody {
    pub left_brace: Span,
    pub members: Vec<ClassishMember>,
    pub right_brace: Span,
}

impl Node for InterfaceBody {
    fn name(&self) -> &'static str {
        "InterfaceBody"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.members]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct InterfaceStatement {
    pub attributes: Vec<AttributeGroup>,
    pub interface: Span,
    pub name: Name,
    pub extends: Option<InterfaceExtends>,
    pub body: InterfaceBody,
}

impl Node for InterfaceStatement {
    fn name(&self) -> &'static str {
        "InterfaceStatement"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.attributes, &self.name, &self.extends, &self.body]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct Literal {
    pub kind: LiteralKind,
    pub token: Token,
}

impl Node for Literal {
    fn name(&self) -> &'static str {
        "Literal"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.kind]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum LiteralKind {
    Integer,
    Float,
    String,
    Missing,
}

impl Node for LiteralKind {
    fn name(&self) -> &'static str {
        "LiteralKind"
    }

    fn children(&self) -> Vec<&dyn Node> {
        match self {
            _ => vec![],
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ForeachStatement {
    pub foreach: Span,
    pub left_parenthesis: Span,
    pub iterator: ForeachStatementIterator,
    pub right_parenthesis: Span,
    pub body: ForeachStatementBody,
}

impl Node for ForeachStatement {
    fn name(&self) -> &'static str {
        "ForeachStatement"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.iterator, &self.body]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ForeachStatementIterator {
    Value {
        expression: Expression,
        r#as: Span,
        ampersand: Option<Span>,
        value: Expression,
    },
    KeyAndValue {
        expression: Expression,
        r#as: Span,
        ampersand: Option<Span>,
        key: Expression,
        double_arrow: Span,
        value: Expression,
    },
}

impl Node for ForeachStatementIterator {
    fn name(&self) -> &'static str {
        "ForeachStatementIterator"
    }

    fn children(&self) -> Vec<&dyn Node> {
        match self {
            Self::Value {
                expression,
                r#as,
                ampersand,
                value,
            } => {
                vec![expression, value]
            }
            Self::KeyAndValue {
                expression,
                r#as,
                ampersand,
                key,
                double_arrow,
                value,
            } => {
                vec![expression, key, value]
            }
            _ => vec![],
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ForeachStatementBody {
    Statement {
        statement: Box<Statement>,
    },
    Block {
        colon: Span,
        statements: Vec<Statement>,
        endforeach: Span,
        ending: Ending,
    },
}

impl Node for ForeachStatementBody {
    fn name(&self) -> &'static str {
        "ForeachStatementBody"
    }

    fn children(&self) -> Vec<&dyn Node> {
        match self {
            Self::Statement { statement } => {
                vec![statement]
            }
            Self::Block {
                colon,
                statements,
                endforeach,
                ending,
            } => {
                vec![statements, ending]
            }
            _ => vec![],
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ForStatement {
    pub r#for: Span,
    pub left_parenthesis: Span,
    pub iterator: ForStatementIterator,
    pub right_parenthesis: Span,
    pub body: ForStatementBody,
}

impl Node for ForStatement {
    fn name(&self) -> &'static str {
        "ForStatement"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.iterator, &self.body]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ForStatementIterator {
    pub initializations: CommaSeparated<Expression>,
    pub initializations_semicolon: Span,
    pub conditions: CommaSeparated<Expression>,
    pub conditions_semicolon: Span,
    pub r#loop: CommaSeparated<Expression>,
}

impl Node for ForStatementIterator {
    fn name(&self) -> &'static str {
        "ForStatementIterator"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.initializations, &self.conditions, &self.r#loop]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ForStatementBody {
    Statement {
        statement: Box<Statement>,
    },
    Block {
        colon: Span,
        statements: Vec<Statement>,
        endfor: Span,
        ending: Ending,
    },
}

impl Node for ForStatementBody {
    fn name(&self) -> &'static str {
        "ForStatementBody"
    }

    fn children(&self) -> Vec<&dyn Node> {
        match self {
            Self::Statement { statement } => {
                vec![statement]
            }
            Self::Block {
                colon,
                statements,
                endfor,
                ending,
            } => {
                vec![statements, ending]
            }
            _ => vec![],
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct DoWhileStatement {
    pub r#do: Span,
    pub body: Box<Statement>,
    pub r#while: Span,
    pub left_parenthesis: Span,
    pub condition: Expression,
    pub right_parenthesis: Span,
    pub semicolon: Span,
}

impl Node for DoWhileStatement {
    fn name(&self) -> &'static str {
        "DoWhileStatement"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.body, &self.condition]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct WhileStatement {
    pub r#while: Span,
    pub left_parenthesis: Span,
    pub condition: Expression,
    pub right_parenthesis: Span,
    pub body: WhileStatementBody,
}

impl Node for WhileStatement {
    fn name(&self) -> &'static str {
        "WhileStatement"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.condition, &self.body]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum WhileStatementBody {
    Statement {
        statement: Box<Statement>,
    },
    Block {
        colon: Span,
        statements: Vec<Statement>,
        endwhile: Span,
        ending: Ending,
    },
}

impl Node for WhileStatementBody {
    fn name(&self) -> &'static str {
        "WhileStatementBody"
    }

    fn children(&self) -> Vec<&dyn Node> {
        match self {
            Self::Statement { statement } => {
                vec![statement]
            }
            Self::Block {
                colon,
                statements,
                endwhile,
                ending,
            } => {
                vec![statements, ending]
            }
            _ => vec![],
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum Level {
    Literal(Literal),
    Parenthesized {
        left_parenthesis: Span,
        level: Box<Level>,
        right_parenthesis: Span,
    },
}

impl Node for Level {
    fn name(&self) -> &'static str {
        "Level"
    }

    fn children(&self) -> Vec<&dyn Node> {
        match self {
            Self::Literal(node) => vec![node],
            Self::Parenthesized {
                left_parenthesis,
                level,
                right_parenthesis,
            } => {
                vec![level]
            }
            _ => vec![],
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct BreakStatement {
    pub r#break: Span,
    pub level: Option<Level>,
    pub ending: Ending,
}

impl Node for BreakStatement {
    fn name(&self) -> &'static str {
        "BreakStatement"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.level, &self.ending]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ContinueStatement {
    pub r#continue: Span,
    pub level: Option<Level>,
    pub ending: Ending,
}

impl Node for ContinueStatement {
    fn name(&self) -> &'static str {
        "ContinueStatement"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.level, &self.ending]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum VisibilityModifier {
    Public(Span),
    Protected(Span),
    Private(Span),
}

impl Node for VisibilityModifier {
    fn name(&self) -> &'static str {
        "VisibilityModifier"
    }

    fn children(&self) -> Vec<&dyn Node> {
        match self {
            _ => vec![],
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum PromotedPropertyModifier {
    Public(Span),
    Protected(Span),
    Private(Span),
    Readonly(Span),
}

impl Node for PromotedPropertyModifier {
    fn name(&self) -> &'static str {
        "PromotedPropertyModifier"
    }

    fn children(&self) -> Vec<&dyn Node> {
        match self {
            _ => vec![],
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone, Default)]
pub struct PromotedPropertyModifierGroup {
    pub modifiers: Vec<PromotedPropertyModifier>,
}

impl Node for PromotedPropertyModifierGroup {
    fn name(&self) -> &'static str {
        "PromotedPropertyModifierGroup"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.modifiers]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum PropertyModifier {
    Public(Span),
    Protected(Span),
    Private(Span),
    Static(Span),
    Readonly(Span),
}

impl Node for PropertyModifier {
    fn name(&self) -> &'static str {
        "PropertyModifier"
    }

    fn children(&self) -> Vec<&dyn Node> {
        match self {
            _ => vec![],
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone, Default)]
pub struct PropertyModifierGroup {
    pub modifiers: Vec<PropertyModifier>,
}

impl Node for PropertyModifierGroup {
    fn name(&self) -> &'static str {
        "PropertyModifierGroup"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.modifiers]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum MethodModifier {
    Public(Span),
    Protected(Span),
    Private(Span),
    Static(Span),
    Abstract(Span),
    Final(Span),
}

impl Node for MethodModifier {
    fn name(&self) -> &'static str {
        "MethodModifier"
    }

    fn children(&self) -> Vec<&dyn Node> {
        match self {
            _ => vec![],
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone, Default)]
pub struct MethodModifierGroup {
    pub modifiers: Vec<MethodModifier>,
}

impl Node for MethodModifierGroup {
    fn name(&self) -> &'static str {
        "MethodModifierGroup"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.modifiers]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ClassModifier {
    Abstract(Span),
    Final(Span),
    Readonly(Span),
}

impl Node for ClassModifier {
    fn name(&self) -> &'static str {
        "ClassModifier"
    }

    fn children(&self) -> Vec<&dyn Node> {
        match self {
            _ => vec![],
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone, Default)]
pub struct ClassModifierGroup {
    pub modifiers: Vec<ClassModifier>,
}

impl Node for ClassModifierGroup {
    fn name(&self) -> &'static str {
        "ClassModifierGroup"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.modifiers]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ConstantModifier {
    Public(Span),
    Protected(Span),
    Private(Span),
    Final(Span),
}

impl Node for ConstantModifier {
    fn name(&self) -> &'static str {
        "ConstantModifier"
    }

    fn children(&self) -> Vec<&dyn Node> {
        match self {
            _ => vec![],
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ConstantModifierGroup {
    pub modifiers: Vec<ConstantModifier>,
}

impl Node for ConstantModifierGroup {
    fn name(&self) -> &'static str {
        "ConstantModifierGroup"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.modifiers]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct UnbracedNamespace {
    pub start: Span,
    pub name: Name,
    pub end: Span,
    pub statements: Vec<Statement>,
}

impl Node for UnbracedNamespace {
    fn name(&self) -> &'static str {
        "UnbracedNamespace"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.name, &self.statements]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct BracedNamespace {
    pub namespace: Span,
    pub name: Option<Name>,
    pub body: BracedNamespaceBody,
}

impl Node for BracedNamespace {
    fn name(&self) -> &'static str {
        "BracedNamespace"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.name, &self.body]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct BracedNamespaceBody {
    pub start: Span,
    pub end: Span,
    pub statements: Vec<Statement>,
}

impl Node for BracedNamespaceBody {
    fn name(&self) -> &'static str {
        "BracedNamespaceBody"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.statements]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum NamespaceStatement {
    Unbraced(UnbracedNamespace),
    Braced(BracedNamespace),
}

impl Node for NamespaceStatement {
    fn name(&self) -> &'static str {
        "NamespaceStatement"
    }

    fn children(&self) -> Vec<&dyn Node> {
        match self {
            Self::Unbraced(node) => vec![node],
            Self::Braced(node) => vec![node],
            _ => vec![],
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ArithmeticOperationExpression {
    Addition {
        left: Box<Expression>,
        plus: Span,
        right: Box<Expression>,
    },
    Subtraction {
        left: Box<Expression>,
        minus: Span,
        right: Box<Expression>,
    },
    Multiplication {
        left: Box<Expression>,
        asterisk: Span,
        right: Box<Expression>,
    },
    Division {
        left: Box<Expression>,
        slash: Span,
        right: Box<Expression>,
    },
    Modulo {
        left: Box<Expression>,
        percent: Span,
        right: Box<Expression>,
    },
    Exponentiation {
        left: Box<Expression>,
        pow: Span,
        right: Box<Expression>,
    },
    Negative {
        minus: Span,
        right: Box<Expression>,
    },
    Positive {
        plus: Span,
        right: Box<Expression>,
    },
    PreIncrement {
        increment: Span,
        right: Box<Expression>,
    },
    PostIncrement {
        left: Box<Expression>,
        increment: Span,
    },
    PreDecrement {
        decrement: Span,
        right: Box<Expression>,
    },
    PostDecrement {
        left: Box<Expression>,
        decrement: Span,
    },
}

impl Node for ArithmeticOperationExpression {
    fn name(&self) -> &'static str {
        "ArithmeticOperationExpression"
    }

    fn children(&self) -> Vec<&dyn Node> {
        match self {
            Self::Addition { left, plus, right } => {
                vec![left, right]
            }
            Self::Subtraction { left, minus, right } => {
                vec![left, right]
            }
            Self::Multiplication {
                left,
                asterisk,
                right,
            } => {
                vec![left, right]
            }
            Self::Division { left, slash, right } => {
                vec![left, right]
            }
            Self::Modulo {
                left,
                percent,
                right,
            } => {
                vec![left, right]
            }
            Self::Exponentiation { left, pow, right } => {
                vec![left, right]
            }
            Self::Negative { minus, right } => {
                vec![right]
            }
            Self::Positive { plus, right } => {
                vec![right]
            }
            Self::PreIncrement { increment, right } => {
                vec![right]
            }
            Self::PostIncrement { left, increment } => {
                vec![left]
            }
            Self::PreDecrement { decrement, right } => {
                vec![right]
            }
            Self::PostDecrement { left, decrement } => {
                vec![left]
            }
            _ => vec![],
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum AssignmentOperationExpression {
    Assign {
        left: Box<Expression>,
        equals: Span,
        right: Box<Expression>,
    },
    Addition {
        left: Box<Expression>,
        plus_equals: Span,
        right: Box<Expression>,
    },
    Subtraction {
        left: Box<Expression>,
        minus_equals: Span,
        right: Box<Expression>,
    },
    Multiplication {
        left: Box<Expression>,
        asterisk_equals: Span,
        right: Box<Expression>,
    },
    Division {
        left: Box<Expression>,
        slash_equals: Span,
        right: Box<Expression>,
    },
    Modulo {
        left: Box<Expression>,
        percent_equals: Span,
        right: Box<Expression>,
    },
    Exponentiation {
        left: Box<Expression>,
        pow_equals: Span,
        right: Box<Expression>,
    },
    Concat {
        left: Box<Expression>,
        dot_equals: Span,
        right: Box<Expression>,
    },
    BitwiseAnd {
        left: Box<Expression>,
        ampersand_equals: Span,
        right: Box<Expression>,
    },
    BitwiseOr {
        left: Box<Expression>,
        pipe_equals: Span,
        right: Box<Expression>,
    },
    BitwiseXor {
        left: Box<Expression>,
        caret_equals: Span,
        right: Box<Expression>,
    },
    LeftShift {
        left: Box<Expression>,
        left_shift_equals: Span,
        right: Box<Expression>,
    },
    RightShift {
        left: Box<Expression>,
        right_shift_equals: Span,
        right: Box<Expression>,
    },
    Coalesce {
        left: Box<Expression>,
        coalesce_equals: Span,
        right: Box<Expression>,
    },
}

impl Node for AssignmentOperationExpression {
    fn name(&self) -> &'static str {
        "AssignmentOperationExpression"
    }

    fn children(&self) -> Vec<&dyn Node> {
        match self {
            Self::Assign {
                left,
                equals,
                right,
            } => {
                vec![left, right]
            }
            Self::Addition {
                left,
                plus_equals,
                right,
            } => {
                vec![left, right]
            }
            Self::Subtraction {
                left,
                minus_equals,
                right,
            } => {
                vec![left, right]
            }
            Self::Multiplication {
                left,
                asterisk_equals,
                right,
            } => {
                vec![left, right]
            }
            Self::Division {
                left,
                slash_equals,
                right,
            } => {
                vec![left, right]
            }
            Self::Modulo {
                left,
                percent_equals,
                right,
            } => {
                vec![left, right]
            }
            Self::Exponentiation {
                left,
                pow_equals,
                right,
            } => {
                vec![left, right]
            }
            Self::Concat {
                left,
                dot_equals,
                right,
            } => {
                vec![left, right]
            }
            Self::BitwiseAnd {
                left,
                ampersand_equals,
                right,
            } => {
                vec![left, right]
            }
            Self::BitwiseOr {
                left,
                pipe_equals,
                right,
            } => {
                vec![left, right]
            }
            Self::BitwiseXor {
                left,
                caret_equals,
                right,
            } => {
                vec![left, right]
            }
            Self::LeftShift {
                left,
                left_shift_equals,
                right,
            } => {
                vec![left, right]
            }
            Self::RightShift {
                left,
                right_shift_equals,
                right,
            } => {
                vec![left, right]
            }
            Self::Coalesce {
                left,
                coalesce_equals,
                right,
            } => {
                vec![left, right]
            }
            _ => vec![],
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum BitwiseOperationExpression {
    And {
        left: Box<Expression>,
        and: Span,
        right: Box<Expression>,
    },
    Or {
        left: Box<Expression>,
        or: Span,
        right: Box<Expression>,
    },
    Xor {
        left: Box<Expression>,
        xor: Span,
        right: Box<Expression>,
    },
    LeftShift {
        left: Box<Expression>,
        left_shift: Span,
        right: Box<Expression>,
    },
    RightShift {
        left: Box<Expression>,
        right_shift: Span,
        right: Box<Expression>,
    },
    Not {
        not: Span,
        right: Box<Expression>,
    },
}

impl Node for BitwiseOperationExpression {
    fn name(&self) -> &'static str {
        "BitwiseOperationExpression"
    }

    fn children(&self) -> Vec<&dyn Node> {
        match self {
            Self::And { left, and, right } => {
                vec![left, right]
            }
            Self::Or { left, or, right } => {
                vec![left, right]
            }
            Self::Xor { left, xor, right } => {
                vec![left, right]
            }
            Self::LeftShift {
                left,
                left_shift,
                right,
            } => {
                vec![left, right]
            }
            Self::RightShift {
                left,
                right_shift,
                right,
            } => {
                vec![left, right]
            }
            Self::Not { not, right } => {
                vec![right]
            }
            _ => vec![],
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ComparisonOperationExpression {
    Equal {
        left: Box<Expression>,
        double_equals: Span,
        right: Box<Expression>,
    },
    Identical {
        left: Box<Expression>,
        triple_equals: Span,
        right: Box<Expression>,
    },
    NotEqual {
        left: Box<Expression>,
        bang_equals: Span,
        right: Box<Expression>,
    },
    AngledNotEqual {
        left: Box<Expression>,
        angled_left_right: Span,
        right: Box<Expression>,
    },
    NotIdentical {
        left: Box<Expression>,
        bang_double_equals: Span,
        right: Box<Expression>,
    },
    LessThan {
        left: Box<Expression>,
        less_than: Span,
        right: Box<Expression>,
    },
    GreaterThan {
        left: Box<Expression>,
        greater_than: Span,
        right: Box<Expression>,
    },
    LessThanOrEqual {
        left: Box<Expression>,
        less_than_equals: Span,
        right: Box<Expression>,
    },
    GreaterThanOrEqual {
        left: Box<Expression>,
        greater_than_equals: Span,
        right: Box<Expression>,
    },
    Spaceship {
        left: Box<Expression>,
        spaceship: Span,
        right: Box<Expression>,
    },
}

impl Node for ComparisonOperationExpression {
    fn name(&self) -> &'static str {
        "ComparisonOperationExpression"
    }

    fn children(&self) -> Vec<&dyn Node> {
        match self {
            Self::Equal {
                left,
                double_equals,
                right,
            } => {
                vec![left, right]
            }
            Self::Identical {
                left,
                triple_equals,
                right,
            } => {
                vec![left, right]
            }
            Self::NotEqual {
                left,
                bang_equals,
                right,
            } => {
                vec![left, right]
            }
            Self::AngledNotEqual {
                left,
                angled_left_right,
                right,
            } => {
                vec![left, right]
            }
            Self::NotIdentical {
                left,
                bang_double_equals,
                right,
            } => {
                vec![left, right]
            }
            Self::LessThan {
                left,
                less_than,
                right,
            } => {
                vec![left, right]
            }
            Self::GreaterThan {
                left,
                greater_than,
                right,
            } => {
                vec![left, right]
            }
            Self::LessThanOrEqual {
                left,
                less_than_equals,
                right,
            } => {
                vec![left, right]
            }
            Self::GreaterThanOrEqual {
                left,
                greater_than_equals,
                right,
            } => {
                vec![left, right]
            }
            Self::Spaceship {
                left,
                spaceship,
                right,
            } => {
                vec![left, right]
            }
            _ => vec![],
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum LogicalOperationExpression {
    And {
        left: Box<Expression>,
        double_ampersand: Span,
        right: Box<Expression>,
    },
    Or {
        left: Box<Expression>,
        double_pipe: Span,
        right: Box<Expression>,
    },
    Not {
        bang: Span,
        right: Box<Expression>,
    },
    LogicalAnd {
        left: Box<Expression>,
        and: Span,
        right: Box<Expression>,
    },
    LogicalOr {
        left: Box<Expression>,
        or: Span,
        right: Box<Expression>,
    },
    LogicalXor {
        left: Box<Expression>,
        xor: Span,
        right: Box<Expression>,
    },
}

impl Node for LogicalOperationExpression {
    fn name(&self) -> &'static str {
        "LogicalOperationExpression"
    }

    fn children(&self) -> Vec<&dyn Node> {
        match self {
            Self::And {
                left,
                double_ampersand,
                right,
            } => {
                vec![left, right]
            }
            Self::Or {
                left,
                double_pipe,
                right,
            } => {
                vec![left, right]
            }
            Self::Not { bang, right } => {
                vec![right]
            }
            Self::LogicalAnd { left, and, right } => {
                vec![left, right]
            }
            Self::LogicalOr { left, or, right } => {
                vec![left, right]
            }
            Self::LogicalXor { left, xor, right } => {
                vec![left, right]
            }
            _ => vec![],
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone, Copy)]
pub struct Name {
    pub kind: NameKind,
    pub span: Span,
}

impl Node for Name {
    fn name(&self) -> &'static str {
        "Name"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.kind]
    }
}

#[derive(Debug, PartialEq, Eq, Clone, Copy)]
pub enum NameKind {
    Special(SpecialName),
    Unresolved(UnresolvedName),
    Resolved(ResolvedName),
}

impl Node for NameKind {
    fn name(&self) -> &'static str {
        "NameKind"
    }

    fn children(&self) -> Vec<&dyn Node> {
        match self {
            Self::Special(node) => vec![node],
            Self::Unresolved(node) => vec![node],
            Self::Resolved(node) => vec![node],
            _ => vec![],
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone, Copy)]
pub struct SpecialName {
    pub kind: SpecialNameKind,
    pub symbol: Symbol,
}

impl Node for SpecialName {
    fn name(&self) -> &'static str {
        "SpecialName"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.kind]
    }
}

#[derive(Debug, PartialEq, Eq, Clone, Copy)]
pub enum SpecialNameKind {
    Self_,
    Parent,
    Static,
}

impl Node for SpecialNameKind {
    fn name(&self) -> &'static str {
        "SpecialNameKind"
    }

    fn children(&self) -> Vec<&dyn Node> {
        match self {
            _ => vec![],
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone, Copy)]
pub struct UnresolvedName {
    pub symbol: Symbol,
    pub qualification: NameQualification,
}

impl Node for UnresolvedName {
    fn name(&self) -> &'static str {
        "UnresolvedName"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![]
    }
}

#[derive(Debug, PartialEq, Eq, Clone, Copy)]
pub struct ResolvedName {
    pub resolved: Symbol,
    pub original: Symbol,
}

impl Node for ResolvedName {
    fn name(&self) -> &'static str {
        "ResolvedName"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct Property {
    pub attributes: Vec<AttributeGroup>,
    pub modifiers: PropertyModifierGroup,
    pub r#type: Option<DataType>,
    pub entries: Vec<PropertyEntry>,
    pub end: Span,
}

impl Node for Property {
    fn name(&self) -> &'static str {
        "Property"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![
            &self.attributes,
            &self.modifiers,
            &self.r#type,
            &self.entries,
        ]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct VariableProperty {
    pub attributes: Vec<AttributeGroup>,
    pub r#type: Option<DataType>,
    pub entries: Vec<PropertyEntry>,
    pub end: Span,
}

impl Node for VariableProperty {
    fn name(&self) -> &'static str {
        "VariableProperty"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.attributes, &self.r#type, &self.entries]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum PropertyEntry {
    Uninitialized {
        variable: SimpleVariable,
    },
    Initialized {
        variable: SimpleVariable,
        equals: Span,
        value: Expression,
    },
}

impl Node for PropertyEntry {
    fn name(&self) -> &'static str {
        "PropertyEntry"
    }

    fn children(&self) -> Vec<&dyn Node> {
        match self {
            Self::Uninitialized { variable } => {
                vec![variable]
            }
            Self::Initialized {
                variable,
                equals,
                value,
            } => {
                vec![variable, value]
            }
            _ => vec![],
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct TraitBody {
    pub left_brace: Span,
    pub members: Vec<ClassishMember>,
    pub right_brace: Span,
}

impl Node for TraitBody {
    fn name(&self) -> &'static str {
        "TraitBody"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.members]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct TraitStatement {
    pub r#trait: Span,
    pub name: Name,
    pub attributes: Vec<AttributeGroup>,
    pub body: TraitBody,
}

impl Node for TraitStatement {
    fn name(&self) -> &'static str {
        "TraitStatement"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.name, &self.attributes, &self.body]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct TraitUsage {
    pub r#use: Span,
    pub traits: Vec<Name>,
    pub adaptations: Vec<TraitUsageAdaptation>,
}

impl Node for TraitUsage {
    fn name(&self) -> &'static str {
        "TraitUsage"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.traits, &self.adaptations]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum TraitUsageAdaptation {
    Alias {
        r#trait: Option<Name>,
        method: SimpleIdentifier,
        alias: SimpleIdentifier,
        visibility: Option<VisibilityModifier>,
    },
    Visibility {
        r#trait: Option<Name>,
        method: SimpleIdentifier,
        visibility: VisibilityModifier,
    },
    Precedence {
        r#trait: Option<Name>,
        method: SimpleIdentifier,
        insteadof: Vec<SimpleIdentifier>,
    },
}

impl Node for TraitUsageAdaptation {
    fn name(&self) -> &'static str {
        "TraitUsageAdaptation"
    }

    fn children(&self) -> Vec<&dyn Node> {
        match self {
            Self::Alias {
                r#trait,
                method,
                alias,
                visibility,
            } => {
                vec![r#trait, method, alias, visibility]
            }
            Self::Visibility {
                r#trait,
                method,
                visibility,
            } => {
                vec![r#trait, method, visibility]
            }
            Self::Precedence {
                r#trait,
                method,
                insteadof,
            } => {
                vec![r#trait, method, insteadof]
            }
            _ => vec![],
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum CatchType {
    Identifier { identifier: SimpleIdentifier },
    Union { identifiers: Vec<SimpleIdentifier> },
}

impl Node for CatchType {
    fn name(&self) -> &'static str {
        "CatchType"
    }

    fn children(&self) -> Vec<&dyn Node> {
        match self {
            Self::Identifier { identifier } => {
                vec![identifier]
            }
            Self::Union { identifiers } => {
                vec![identifiers]
            }
            _ => vec![],
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct TryStatement {
    pub start: Span,
    pub end: Span,
    pub body: Block,
    pub catches: Vec<CatchBlock>,
    pub finally: Option<FinallyBlock>,
}

impl Node for TryStatement {
    fn name(&self) -> &'static str {
        "TryStatement"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.body, &self.catches, &self.finally]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct CatchBlock {
    pub start: Span,
    pub end: Span,
    pub types: CatchType,
    pub var: Option<SimpleVariable>,
    pub body: Block,
}

impl Node for CatchBlock {
    fn name(&self) -> &'static str {
        "CatchBlock"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.types, &self.var, &self.body]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct FinallyBlock {
    pub start: Span,
    pub end: Span,
    pub body: Block,
}

impl Node for FinallyBlock {
    fn name(&self) -> &'static str {
        "FinallyBlock"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.body]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum Variable {
    SimpleVariable(SimpleVariable),
    VariableVariable(VariableVariable),
    BracedVariableVariable(BracedVariableVariable),
}

impl Node for Variable {
    fn name(&self) -> &'static str {
        "Variable"
    }

    fn children(&self) -> Vec<&dyn Node> {
        match self {
            Self::SimpleVariable(node) => vec![node],
            Self::VariableVariable(node) => vec![node],
            Self::BracedVariableVariable(node) => vec![node],
            _ => vec![],
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct SimpleVariable {
    pub symbol: Symbol,
    pub stripped: Symbol,
    pub span: Span,
}

impl Node for SimpleVariable {
    fn name(&self) -> &'static str {
        "SimpleVariable"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct VariableVariable {
    pub span: Span,
    pub variable: Box<Variable>,
}

impl Node for VariableVariable {
    fn name(&self) -> &'static str {
        "VariableVariable"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.variable]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct BracedVariableVariable {
    pub start: Span,
    pub variable: Box<Expression>,
    pub end: Span,
}

impl Node for BracedVariableVariable {
    fn name(&self) -> &'static str {
        "BracedVariableVariable"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.variable]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum Ending {
    Missing(Span),
    Semicolon(Span),
    CloseTag(Span),
}

impl Node for Ending {
    fn name(&self) -> &'static str {
        "Ending"
    }

    fn children(&self) -> Vec<&dyn Node> {
        match self {
            _ => vec![],
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct StaticStatement {
    pub vars: Vec<StaticVar>,
}

impl Node for StaticStatement {
    fn name(&self) -> &'static str {
        "StaticStatement"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.vars]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct SwitchStatement {
    pub switch: Span,
    pub left_parenthesis: Span,
    pub condition: Expression,
    pub right_parenthesis: Span,
    pub cases: Vec<Case>,
}

impl Node for SwitchStatement {
    fn name(&self) -> &'static str {
        "SwitchStatement"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.condition, &self.cases]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct EchoStatement {
    pub echo: Span,
    pub values: Vec<Expression>,
    pub ending: Ending,
}

impl Node for EchoStatement {
    fn name(&self) -> &'static str {
        "EchoStatement"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.values, &self.ending]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ReturnStatement {
    pub r#return: Span,
    pub value: Option<Expression>,
    pub ending: Ending,
}

impl Node for ReturnStatement {
    fn name(&self) -> &'static str {
        "ReturnStatement"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.value, &self.ending]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct UseStatement {
    pub kind: UseKind,
    pub uses: Vec<Use>,
}

impl Node for UseStatement {
    fn name(&self) -> &'static str {
        "UseStatement"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.kind, &self.uses]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct GroupUseStatement {
    pub prefix: SimpleIdentifier,
    pub kind: UseKind,
    pub uses: Vec<Use>,
}

impl Node for GroupUseStatement {
    fn name(&self) -> &'static str {
        "GroupUseStatement"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.prefix, &self.kind, &self.uses]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct HaltCompilerStatement {
    pub content: Option<Token>,
}

impl Node for HaltCompilerStatement {
    fn name(&self) -> &'static str {
        "HaltCompilerStatement"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![]
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct StaticVar {
    pub var: Variable,
    pub default: Option<Expression>,
}

impl Node for StaticVar {
    fn name(&self) -> &'static str {
        "StaticVar"
    }

    fn children(&self) -> Vec<&dyn Node> {
        vec![&self.var, &self.default]
    }
}
